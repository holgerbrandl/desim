{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to kalasim kalasim is a discrete event simulator that enables complex, dynamic process models. It provides a statically typed API, dependency injection, modern persistence, structured logging and automation capabilities. kalasim is written in Kotlin , is designed around suspendable coroutines for process definitions, runs on the JVM for performance and scale, is built with koin as dependency wiring framework, and is using common-math for stats and distributions. See acknowledgements for further references. One cornerstone of successful discrete event simulation is visualization. kalasim is agnostic regarding a visualization frontend, but we provide bindings/examples using plotly.kt , lets-plot as well as kravis . In contrast to many other simulation tools, kalasim is neither low-code nor no-code. It is code-first to enable change tracking, scaling, refactoring, CI/CD, unit-tests, and the rest of the gang that makes simulation development fun. Core Features kalasim is a generic process-oriented discrete event simulation (DES) engine. Simulation entities have a generative process description that defines the interplay with other entities There is a well-defined rich process interaction vocabulary, including hold , request , wait or passivate An event trigger queue maintains future action triggers and acts as sole driver to progress simulation state Built-in monitoring and statistics gathering across the entire API Find out more about the basics of a kalasim simulation. First Example Let\u2019s start with a very simple model. The example demonstrates the main mode of operation, the core API and the component process model implemented in kalasim . We want to build a simulation where a single car is driving around for a some time before arriving at its destination. ////Cars.kts import org.kalasim.* class Driver : Resource () class TrafficLight : State < String > ( \"red\" ) class Car : Component () { val trafficLight = get < TrafficLight > () val driver = get < Driver > () override fun process () = sequence { request ( driver ) { hold ( 1.0 , description = \"driving\" ) wait ( trafficLight , \"green\" ) } } } createSimulation ( enableConsoleLogger = true ) { dependency { TrafficLight () } dependency { Driver () } Car () }. run ( 5.0 ) Curious about an in-depth analysis of this example? It's your lucky day, see here . How to contribute? Feel welcome to post ideas and suggestions to the project tracker . We always welcome pull requests. :-) Support Feel welcome to post questions and ideas in the project's gitter chat Feel also invited to chat with us in the kotlinlang.slack.com in the #datascience channel.","title":"Introduction"},{"location":"#welcome-to-kalasim","text":"kalasim is a discrete event simulator that enables complex, dynamic process models. It provides a statically typed API, dependency injection, modern persistence, structured logging and automation capabilities. kalasim is written in Kotlin , is designed around suspendable coroutines for process definitions, runs on the JVM for performance and scale, is built with koin as dependency wiring framework, and is using common-math for stats and distributions. See acknowledgements for further references. One cornerstone of successful discrete event simulation is visualization. kalasim is agnostic regarding a visualization frontend, but we provide bindings/examples using plotly.kt , lets-plot as well as kravis . In contrast to many other simulation tools, kalasim is neither low-code nor no-code. It is code-first to enable change tracking, scaling, refactoring, CI/CD, unit-tests, and the rest of the gang that makes simulation development fun.","title":"Welcome to kalasim"},{"location":"#core-features","text":"kalasim is a generic process-oriented discrete event simulation (DES) engine. Simulation entities have a generative process description that defines the interplay with other entities There is a well-defined rich process interaction vocabulary, including hold , request , wait or passivate An event trigger queue maintains future action triggers and acts as sole driver to progress simulation state Built-in monitoring and statistics gathering across the entire API Find out more about the basics of a kalasim simulation.","title":"Core Features"},{"location":"#first-example","text":"Let\u2019s start with a very simple model. The example demonstrates the main mode of operation, the core API and the component process model implemented in kalasim . We want to build a simulation where a single car is driving around for a some time before arriving at its destination. ////Cars.kts import org.kalasim.* class Driver : Resource () class TrafficLight : State < String > ( \"red\" ) class Car : Component () { val trafficLight = get < TrafficLight > () val driver = get < Driver > () override fun process () = sequence { request ( driver ) { hold ( 1.0 , description = \"driving\" ) wait ( trafficLight , \"green\" ) } } } createSimulation ( enableConsoleLogger = true ) { dependency { TrafficLight () } dependency { Driver () } Car () }. run ( 5.0 ) Curious about an in-depth analysis of this example? It's your lucky day, see here .","title":"First Example"},{"location":"#how-to-contribute","text":"Feel welcome to post ideas and suggestions to the project tracker . We always welcome pull requests. :-)","title":"How to contribute?"},{"location":"#support","text":"Feel welcome to post questions and ideas in the project's gitter chat Feel also invited to chat with us in the kotlinlang.slack.com in the #datascience channel.","title":"Support"},{"location":"about/","text":"About License kalasim is licensed under MIT License. Acknowledgements salabim kalasim started off as a blunt rewrite of salabim . We are deeply thankful for its permissive licence that enabled setting up kalasim . A great starting point was in particular the wonderful article salabim: discrete event simulation and animation in Python . salabim s excellent documentation and wonderful examples made this project possible after all. kalasim reimplements all core APIs of salabim in a more typesafe API while also providing better test coverage, real-time capabilities and (arguably) more modern built-in support for visualization. Salabim, Discrete Event Simulation In Python - PyCon 2018 Talk Python. init Podcast: Salabim - Great podcast episode with Ruud van der Ham simmer simmer is a process-oriented and trajectory-based Discrete-Event Simulation (DES) package for R. It centres around the concept of a trajectory that defines a component lifecycle. To enable scale it is built on top of Rcpp (C++ backend for R). Great overview simmer: Discrete-Event Simulation for R , Ucar et al., 2019 Support for optimization in simmer.optim We have adopted several examples and documentation bits from simmer , and are deeply grateful to the simmer developers for providing such a great and well maintained tool. simmer has also been a great source of inspiration to implement in particular the monitoring and visualization API of kalasim . SimJulia SimJulia is a combined continuous time / discrete event process oriented simulation framework written in Julia inspired by the Simula library DISCO and the Python library SimPy. We have adopted several examples and documentation bits from SimJulia , and are deeply grateful its developers for providing such a great and well maintained tool. SimPy SimPy is a process-based discrete-event simulation framework based on standard Python. Processes in SimPy are defined by Python generator functions. SimPy also provides various types of shared resources to model limited capacity congestion points (like servers, checkout counters and tunnels). We have adopted several examples and documentation bits from SimPy , and are deeply grateful its developers for providing such a great and well maintained tool. DSOL DSOL3 which is an open source, Java based suite of Java classes for continuous and discrete event simulation The wonderful DSOL manual The DSOL simulation suite - Enabling multi-formalism simulation in a distributed context , PhD Thesis, Peter Jacobs, 2005 Mastering D-SOL: A Java based suite for simulation with several examples, 2006 opentrafficsim is a traffic simulation built with DSOL3 Libraries used to build kalasim kalasim is built on top of some great libraries. It was derived as merger of ideas, implementation and documentation from the following projects: Kotlin - Not really a library, but for obvious reasons the foundation of this project koin which is a pragmatic lightweight dependency injection framework for Kotlin developers Apache Commons Math is a library of lightweight, self-contained mathematics and statistics components jsonbuilder is a small artifact that serves a single purpose: It allows creating json using an idiomatic kotlin DSL. Its main purpose it to make sure kalasim provides a machine-readable log-format for all basics in a simulation. kotest.io is a flexible and elegant multiplatform test framework, assertions library, and property test library for Kotlin. We use it to make sure kalasim fulfils its component contract. Visualization https://github.com/holgerbrandl/kravis which implements a grammar to create a wide range of plots using a standardized set of verbs Repo Maintainer Holger Brandl holds a Ph.D. degree in machine learning and has developed new concepts in the field of computational linguistics. More recently he has co-authored publications in high-ranking journals such as Nature and Science. To stay in sync with what's happening in tech, he's developing open-source tools, methods and algorithms for bioinformatics, high-performance computing and data science. He's passionate about machine learning, AI, analytics, elegant APIs and data visualisation. His professional scope mainly centers around systems biology and industrial manufacturing.","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#license","text":"kalasim is licensed under MIT License.","title":"License"},{"location":"about/#acknowledgements","text":"","title":"Acknowledgements"},{"location":"about/#salabim","text":"kalasim started off as a blunt rewrite of salabim . We are deeply thankful for its permissive licence that enabled setting up kalasim . A great starting point was in particular the wonderful article salabim: discrete event simulation and animation in Python . salabim s excellent documentation and wonderful examples made this project possible after all. kalasim reimplements all core APIs of salabim in a more typesafe API while also providing better test coverage, real-time capabilities and (arguably) more modern built-in support for visualization. Salabim, Discrete Event Simulation In Python - PyCon 2018 Talk Python. init Podcast: Salabim - Great podcast episode with Ruud van der Ham","title":"salabim"},{"location":"about/#simmer","text":"simmer is a process-oriented and trajectory-based Discrete-Event Simulation (DES) package for R. It centres around the concept of a trajectory that defines a component lifecycle. To enable scale it is built on top of Rcpp (C++ backend for R). Great overview simmer: Discrete-Event Simulation for R , Ucar et al., 2019 Support for optimization in simmer.optim We have adopted several examples and documentation bits from simmer , and are deeply grateful to the simmer developers for providing such a great and well maintained tool. simmer has also been a great source of inspiration to implement in particular the monitoring and visualization API of kalasim .","title":"simmer"},{"location":"about/#simjulia","text":"SimJulia is a combined continuous time / discrete event process oriented simulation framework written in Julia inspired by the Simula library DISCO and the Python library SimPy. We have adopted several examples and documentation bits from SimJulia , and are deeply grateful its developers for providing such a great and well maintained tool.","title":"SimJulia"},{"location":"about/#simpy","text":"SimPy is a process-based discrete-event simulation framework based on standard Python. Processes in SimPy are defined by Python generator functions. SimPy also provides various types of shared resources to model limited capacity congestion points (like servers, checkout counters and tunnels). We have adopted several examples and documentation bits from SimPy , and are deeply grateful its developers for providing such a great and well maintained tool.","title":"SimPy"},{"location":"about/#dsol","text":"DSOL3 which is an open source, Java based suite of Java classes for continuous and discrete event simulation The wonderful DSOL manual The DSOL simulation suite - Enabling multi-formalism simulation in a distributed context , PhD Thesis, Peter Jacobs, 2005 Mastering D-SOL: A Java based suite for simulation with several examples, 2006 opentrafficsim is a traffic simulation built with DSOL3","title":"DSOL"},{"location":"about/#libraries-used-to-build-kalasim","text":"kalasim is built on top of some great libraries. It was derived as merger of ideas, implementation and documentation from the following projects: Kotlin - Not really a library, but for obvious reasons the foundation of this project koin which is a pragmatic lightweight dependency injection framework for Kotlin developers Apache Commons Math is a library of lightweight, self-contained mathematics and statistics components jsonbuilder is a small artifact that serves a single purpose: It allows creating json using an idiomatic kotlin DSL. Its main purpose it to make sure kalasim provides a machine-readable log-format for all basics in a simulation. kotest.io is a flexible and elegant multiplatform test framework, assertions library, and property test library for Kotlin. We use it to make sure kalasim fulfils its component contract. Visualization https://github.com/holgerbrandl/kravis which implements a grammar to create a wide range of plots using a standardized set of verbs","title":"Libraries used to build kalasim"},{"location":"about/#repo-maintainer","text":"Holger Brandl holds a Ph.D. degree in machine learning and has developed new concepts in the field of computational linguistics. More recently he has co-authored publications in high-ranking journals such as Nature and Science. To stay in sync with what's happening in tech, he's developing open-source tools, methods and algorithms for bioinformatics, high-performance computing and data science. He's passionate about machine learning, AI, analytics, elegant APIs and data visualisation. His professional scope mainly centers around systems biology and industrial manufacturing.","title":"Repo Maintainer"},{"location":"advanced/","text":"Clock Synchronization In simulation a clear distinction is made between real time and simulation time. With real time we refer to the wall-clock time. It represents the execution time of the experiment. The simulation time is an attribute of the simulator. To support use cases where a simulation may drive a demonstration or system check, the kalasim API allows to run a simulation at a defined clock speed. Such real-time simulations may be necessary If you have hardware-in-the-loop If the intent of the simulation is to drive a visualization of a process If there is human interaction with your simulation, or If you want to analyze the real-time behavior of an algorithm import org.kalasim.ClockSync import org.kalasim.createSimulation import java.time.Duration val timeBefore = System . currentTimeMillis () createSimulation ( true ) { // enable real-time clock synchronization w ClockSync ( tickDuration = Duration . ofSeconds ( 1 )) // enable real-time clock synchronization but run in 2x realtime // ClockSync(Duration.ofSeconds(1), speedUp = 2) run ( 10 ) } println ( \"time passed ${ System . currentTimeMillis () - timeBefore } )\" ) This example will execute in 10 seconds. Since the simulation is empty (for educational reasons to keep the focus on the clock here), it is entirely idle during that time. To enable clock synchronization, we need to add a ClockSync to our simulation. We need to define what one tick in simulation time corresponds to in wall time. In the example, one tick equals to one second wall time. This is configured with the parameter tickDuration . It defines the duration of a simulation tick in wall clock coordinates. It can be created with Duration.ofSeconds(1) , Duration.ofMinutes(10) and so on . ClockSync also provides settings for more advanced uses-cases To run simulations, in more than realtime, the user can specify speedUp to run a simulation faster ( speedUp > 1) or slower ( speedUp < 1) than realtime. It defaults to 1 , that is no speed-up will be applied. The argument syncsPerTick defines how often a clock synchronization should happen. Per default it synchronizes once per tick (i.e. an 1-increment of simulation time). It may happen that a simulation is too complex to run at a defined clock. In such a situation, it (i.e. Environment.run() ) will throw a ClockOverloadException if the user has specified a maximum delay maxDelay parameter between simulation and wall clock coordinates. Tick Transformation Simulation time is measured in ticks. Usually, a simulation starts at 0 and then progresses through actions such as hold or wait or component generation. To enable a more eye-friendly logging and to stay closer to the system under study, kalasim supports a built in transformation tickTransform to convert from simulation to wall clock. Let's consider the following example //TickTrafoExample.kts import org.kalasim.* import java.time.Duration import java.time.Instant import java.util.concurrent.TimeUnit createSimulation ( true ) { tickTransform = OffsetTransform ( Instant . now (), TimeUnit . MINUTES ) // run until a specific time run ( until = Instant . now (). plus ( Duration . ofHours ( 1 )). asTickTime ()) // run for a given duration run ( Duration . ofHours ( 1 ). asTicks ()) println ( asWallTime ( now )) } This example will run for 2h in total which is transformed to 2x60 ticks, and will report a transform wall time of now plus 120 minutes. It also illustrates the 3 supported provided transformations: asWallTime(tickTime) - Transforms a simulation time (typically now ) to the corresponding wall time. asTickDuration(duration) - Transforms a wall duration into the corresponding amount of ticks. asTickTime(instant) - Transforms an wall Instant to simulation time. Please note that setting this transformation does not impact the actual simulation, which is always carried out in ticks. It can be configured independently from the clock synchronization described above. There is one provided implementation OffsetTransform that can be instantiated with a start time offset the unit of a tick. The user can also implement own transformation by implementing the functional interface TickTransform . Operational Control {Note} This feature is still in preparation and planned for version v0.8, see https://github.com/holgerbrandl/kalasim/issues/9 and roadmap . Even if kalasim tries to provide a simplistic declarative approach to define a simulation, it may come along with computational demands simulation. To allow introspection into time-complexity of the underlying computations, the user may want to use the built-in env.tickMetrics monitor to analyze how much time is spent per time unit (aka tick ). This monitor is not enabled by default and need to enabled when the environment is created by passing tickMetricsEnabled=true Performance tuning There are multiple ways to improve the performance of a simulation. Set the correct AssertMode : The assertion mode determines which internal consistency checks are being performed. The mode can be set to Full (Slowest), Light (default) or Off (Fastest). Depending on simulation logic and complexity, this will improve performance by ~20%. Disable internal event logging: The interaction model is configured by default to provide insights into the simulation via the event log . However, to optimize performance of a simulation a user may want to consume only custom event-types. If so, internal interaction logging can be disabled by setting logCoreInteractions = false when creating/configuring a component . Disable component statistics: Components and queues log various component statistics with built-in monitors which can be disabled to reduce compute and memory footprint of a simulation. To further fine-tune and optimize simulation performance and to reveal bottlenecks, a JVM profiler (such as yourkit ) can be used. Both call-counts and spent-time analysis have been proven useful here. Save and Load Simulations kalasim does not include a default mechanism to serialize and deserialize simulations yet. However, it seems that with xstream that Environment can be saved including its current simulation state across all included entities. It can be restored from the xml snapshot and continued with run() . We have not succeeded to do the same with gson yet. Also, some experiments with kotlinx.serialization were not that successful.","title":"Advanced"},{"location":"advanced/#clock-synchronization","text":"In simulation a clear distinction is made between real time and simulation time. With real time we refer to the wall-clock time. It represents the execution time of the experiment. The simulation time is an attribute of the simulator. To support use cases where a simulation may drive a demonstration or system check, the kalasim API allows to run a simulation at a defined clock speed. Such real-time simulations may be necessary If you have hardware-in-the-loop If the intent of the simulation is to drive a visualization of a process If there is human interaction with your simulation, or If you want to analyze the real-time behavior of an algorithm import org.kalasim.ClockSync import org.kalasim.createSimulation import java.time.Duration val timeBefore = System . currentTimeMillis () createSimulation ( true ) { // enable real-time clock synchronization w ClockSync ( tickDuration = Duration . ofSeconds ( 1 )) // enable real-time clock synchronization but run in 2x realtime // ClockSync(Duration.ofSeconds(1), speedUp = 2) run ( 10 ) } println ( \"time passed ${ System . currentTimeMillis () - timeBefore } )\" ) This example will execute in 10 seconds. Since the simulation is empty (for educational reasons to keep the focus on the clock here), it is entirely idle during that time. To enable clock synchronization, we need to add a ClockSync to our simulation. We need to define what one tick in simulation time corresponds to in wall time. In the example, one tick equals to one second wall time. This is configured with the parameter tickDuration . It defines the duration of a simulation tick in wall clock coordinates. It can be created with Duration.ofSeconds(1) , Duration.ofMinutes(10) and so on . ClockSync also provides settings for more advanced uses-cases To run simulations, in more than realtime, the user can specify speedUp to run a simulation faster ( speedUp > 1) or slower ( speedUp < 1) than realtime. It defaults to 1 , that is no speed-up will be applied. The argument syncsPerTick defines how often a clock synchronization should happen. Per default it synchronizes once per tick (i.e. an 1-increment of simulation time). It may happen that a simulation is too complex to run at a defined clock. In such a situation, it (i.e. Environment.run() ) will throw a ClockOverloadException if the user has specified a maximum delay maxDelay parameter between simulation and wall clock coordinates.","title":"Clock Synchronization"},{"location":"advanced/#tick-transformation","text":"Simulation time is measured in ticks. Usually, a simulation starts at 0 and then progresses through actions such as hold or wait or component generation. To enable a more eye-friendly logging and to stay closer to the system under study, kalasim supports a built in transformation tickTransform to convert from simulation to wall clock. Let's consider the following example //TickTrafoExample.kts import org.kalasim.* import java.time.Duration import java.time.Instant import java.util.concurrent.TimeUnit createSimulation ( true ) { tickTransform = OffsetTransform ( Instant . now (), TimeUnit . MINUTES ) // run until a specific time run ( until = Instant . now (). plus ( Duration . ofHours ( 1 )). asTickTime ()) // run for a given duration run ( Duration . ofHours ( 1 ). asTicks ()) println ( asWallTime ( now )) } This example will run for 2h in total which is transformed to 2x60 ticks, and will report a transform wall time of now plus 120 minutes. It also illustrates the 3 supported provided transformations: asWallTime(tickTime) - Transforms a simulation time (typically now ) to the corresponding wall time. asTickDuration(duration) - Transforms a wall duration into the corresponding amount of ticks. asTickTime(instant) - Transforms an wall Instant to simulation time. Please note that setting this transformation does not impact the actual simulation, which is always carried out in ticks. It can be configured independently from the clock synchronization described above. There is one provided implementation OffsetTransform that can be instantiated with a start time offset the unit of a tick. The user can also implement own transformation by implementing the functional interface TickTransform .","title":"Tick Transformation"},{"location":"advanced/#operational-control","text":"{Note} This feature is still in preparation and planned for version v0.8, see https://github.com/holgerbrandl/kalasim/issues/9 and roadmap . Even if kalasim tries to provide a simplistic declarative approach to define a simulation, it may come along with computational demands simulation. To allow introspection into time-complexity of the underlying computations, the user may want to use the built-in env.tickMetrics monitor to analyze how much time is spent per time unit (aka tick ). This monitor is not enabled by default and need to enabled when the environment is created by passing tickMetricsEnabled=true","title":"Operational Control"},{"location":"advanced/#performance-tuning","text":"There are multiple ways to improve the performance of a simulation. Set the correct AssertMode : The assertion mode determines which internal consistency checks are being performed. The mode can be set to Full (Slowest), Light (default) or Off (Fastest). Depending on simulation logic and complexity, this will improve performance by ~20%. Disable internal event logging: The interaction model is configured by default to provide insights into the simulation via the event log . However, to optimize performance of a simulation a user may want to consume only custom event-types. If so, internal interaction logging can be disabled by setting logCoreInteractions = false when creating/configuring a component . Disable component statistics: Components and queues log various component statistics with built-in monitors which can be disabled to reduce compute and memory footprint of a simulation. To further fine-tune and optimize simulation performance and to reveal bottlenecks, a JVM profiler (such as yourkit ) can be used. Both call-counts and spent-time analysis have been proven useful here.","title":"Performance tuning"},{"location":"advanced/#save-and-load-simulations","text":"kalasim does not include a default mechanism to serialize and deserialize simulations yet. However, it seems that with xstream that Environment can be saved including its current simulation state across all included entities. It can be restored from the xml snapshot and continued with run() . We have not succeeded to do the same with gson yet. Also, some experiments with kotlinx.serialization were not that successful.","title":"Save and Load Simulations"},{"location":"analysis/","text":"Analysis A core aspect when building simulations is to understand, define and modulate the inherent system dynamics. To build a correct simulation, the designer/developer must carefully analyze how states progress over time. To facilitate this process, kalasim offers various means to analyze data created by a simulation The Event Log tracks events in a simulation Monitors track state and statistics of the basic elements within a simulation, and may be used for domain-specific entities as well Lifecycle Records summarize a component's states history visualization to inspect complex spatio-temporal patterns Monitors See chapter about monitors . Event Log See chapter about event logging . Visualization See chapter about visualization . Component Status The state transition of a component provide value insight into its behavior. This is facilitated by lifecycle statistics ComponentLifecycleRecord that summarize a component's states history. These data can also be transformed easily into a table as well val customers : List < Component > // = ... val records : List < ComponentLifecycleRecord > = customers . map { it . toLifeCycleRecord () } records . asDataFrame () This transforms the customers straight into a krangl dataframe with the following structure A DataFrame: 1034 x 11 component createdAt inCurrent inData inDataSince inInterrupted inPassive 1 Vehicle.1 0.366 0 989.724 10.276 0 0 2 Vehicle.2 1.294 0 984.423 15.577 0 0 3 Vehicle.3 1.626 0 989.724 10.276 0 0 4 Vehicle.4 2.794 0 989.724 10.276 0 0 and 1024 more rows, and and 4 more variables: inScheduled, inStandby, inWaiting Clearly if needed, the user may also work with the records directly. For instance to configure a visualization. Replication Running a simulation just once, often does not provide sufficient insights into the dynamics of the system under consideration. Often, the user may want to execute a model many times with altered initial conditions, and then perform a statistical analysis over the output. This is also considered as what-if analyis. See here for simple example. By design kalasim does not make use of parallelism. So when scaling up execution to run in paralell, we need to be careful, that the internal dependency injection (which relates by default to a global context variable) does not cause trouble. See here for an example that defines a parameter grid to be assessed with multi-threading with a simulation run per hyper-parameter.","title":"Analysis"},{"location":"analysis/#analysis","text":"A core aspect when building simulations is to understand, define and modulate the inherent system dynamics. To build a correct simulation, the designer/developer must carefully analyze how states progress over time. To facilitate this process, kalasim offers various means to analyze data created by a simulation The Event Log tracks events in a simulation Monitors track state and statistics of the basic elements within a simulation, and may be used for domain-specific entities as well Lifecycle Records summarize a component's states history visualization to inspect complex spatio-temporal patterns","title":"Analysis"},{"location":"analysis/#monitors","text":"See chapter about monitors .","title":"Monitors"},{"location":"analysis/#event-log","text":"See chapter about event logging .","title":"Event Log"},{"location":"analysis/#visualization","text":"See chapter about visualization .","title":"Visualization"},{"location":"analysis/#component-status","text":"The state transition of a component provide value insight into its behavior. This is facilitated by lifecycle statistics ComponentLifecycleRecord that summarize a component's states history. These data can also be transformed easily into a table as well val customers : List < Component > // = ... val records : List < ComponentLifecycleRecord > = customers . map { it . toLifeCycleRecord () } records . asDataFrame () This transforms the customers straight into a krangl dataframe with the following structure A DataFrame: 1034 x 11 component createdAt inCurrent inData inDataSince inInterrupted inPassive 1 Vehicle.1 0.366 0 989.724 10.276 0 0 2 Vehicle.2 1.294 0 984.423 15.577 0 0 3 Vehicle.3 1.626 0 989.724 10.276 0 0 4 Vehicle.4 2.794 0 989.724 10.276 0 0 and 1024 more rows, and and 4 more variables: inScheduled, inStandby, inWaiting Clearly if needed, the user may also work with the records directly. For instance to configure a visualization.","title":"Component Status"},{"location":"analysis/#replication","text":"Running a simulation just once, often does not provide sufficient insights into the dynamics of the system under consideration. Often, the user may want to execute a model many times with altered initial conditions, and then perform a statistical analysis over the output. This is also considered as what-if analyis. See here for simple example. By design kalasim does not make use of parallelism. So when scaling up execution to run in paralell, we need to be careful, that the internal dependency injection (which relates by default to a global context variable) does not cause trouble. See here for an example that defines a parameter grid to be assessed with multi-threading with a simulation run per hyper-parameter.","title":"Replication"},{"location":"basics/","text":"The beauty of discrete event simulation is its very limited vocabulary which still allow expressing complex system dynamics. In essence, kalasim relies on just a handful of types to model a simulation. Components Resources States Queues Generators Event Queue The core of kalasim is an event queue ordered by scheduled execution time, that maintains a list of events to be executed. To provide good insert, delete and update performance, kalasim is using a PriorityQueue internally. Components are actively and passively scheduled for reevaluating their state. Technically, event execution refers to the continuation of a component's generator or execution function. Kalasim Execution Model Execution Order In the real world, events often appear to happen at the same time . However, in fact events always occur at slightly differing times. Clearly the notion of same depends on the resolution of the used time axis. Birthdays will happen on the same day whereas the precise birth events will always differ in absolute timing. Even if real-world processes may run \"in parallel\", a simulation is processed sequentially and deterministically. With the same random-generator initialization, you will always get the same simulation results when running your simulation multiple times. Although, kalasim supports double-precision to schedule events, events will inevitably arise that are scheduled for the same time . Because of its single-threaded, deterministic execution model (like most DES frameworks), kalasim processes events sequentially \u2013 one after another. If two events are scheduled at the same time, the one scheduled first will also be the processed first (FIFO). As pointed out in Ucar, 2019 , there are many situations where simultaneous events may occur in simulation. To provide a well-defined behavior in such situations, process interaction methods (namely wait , request , activate and reschedule ) support a priority parameter. With priority which is 0 by default, it is possible to sort a component before or after other components, scheduled for the same time. Events with higher priority are executed first in situations where multiple events are scheduled for the same simulation time. In contrast to other DSE implementations, the user does not need to make sure that a resource release() is prioritized over a simultaneous request() . The engine will automatically reschedule tasks accordingly. So the key points to recall are Real world events may appear to happen at the same discretized simulation time Simulation events are processed one after another, even if they are scheduled for the same time Race-conditions between events can be avoided by setting a priority Simulation Runtime Environment The execution context of a kalasim simulation is an Environment , which can be created with val env : Environment = createSimulation ( enableConsoleLogger = true ){ // Create components in here Car () // To disambiguate between multiple simulations, provide a reference to the koin context // The koin argument can be omitted if just a single simulation is being used Component ( koin = getKoin ()) }. run ( 5.0 ) To configure references, an Environment can also be instantiated by configuring dependencies first with configureEnvironment . Check out the Traffic example to learn how that works. Dependency Injection Kalasim is building on top of koin to inject dependencies between elements of a simulation. As pragmatic approach, it is using a global application context by default, but does allow for parallel simulations with Koin Isolation . For a simulation example with multiple Environment see https://github.com/holgerbrandl/kalasim/tree/master/src/test/kotlin/org/kalasim/test/EnvTests.kt Koin does not allow injecting simple types. To inject simple variables, consider using a wrapper class. Example ////SimpleInject.kts import org.kalasim.Component import org.kalasim.add import org.kalasim.configureEnvironment data class Counter ( var value : Int ) class Something ( val counter : Counter ) : Component () { override fun process () = sequence < Component > { counter . value ++ } } configureEnvironment { add { Counter ( 0 ) } add { Something ( get ()) } }. run ( 10 ) For details about how to use lazy injection with inject<T>() and instance retrieval with get<T>() see koin reference . Examples Traffic Car Wash Gas Station Randomness & Distributions Experimentation in a simulation context relates to large part to controlling randomness. Here, this is achieved by using probabilistic distributions which are internally backed by apache-commons-math . A simulation always allows deterministic execution while still supporting pseudo-random sampling. When creating a new simulation environment , the user can provide a random seed which is internally resolved to a random generator to be used in process definitions. createSimulation ( randomSeed = 123 ){ val randomGenerator = rg // which is resolved by Environment receiver } With random generator, the following distributions are supported out of the box (with common defaults where possible) as extension functions on Component and Environment : uniform(lower=0, upper=1) discreteUniform(lower, upper) exponential(mean) normal(mean=0, sd=1) Whenever, distributions are needed in method signatures in kalasim , the more general interface org.apache.commons.math3.distribution.RealDistribution is being used to support a much wider variety of distributions if needed. So we can also use other implementations as well. For example ComponentGenerator ( iat = NakagamiDistribution ( 1 , 0.3 )){ Customer () } The API also include some convenience wrappers to provide fixed values for argument of RealDistribution . E.g. consider the time until a request is considered as failed: val dist = 3. asConstantDist () ComponentGenerator ( iat = dist ){ Customer () } Here, 3 is converted into a org.apache.commons.math3.distribution.ConstantRealDistribution .","title":"Simulation Basics"},{"location":"basics/#event-queue","text":"The core of kalasim is an event queue ordered by scheduled execution time, that maintains a list of events to be executed. To provide good insert, delete and update performance, kalasim is using a PriorityQueue internally. Components are actively and passively scheduled for reevaluating their state. Technically, event execution refers to the continuation of a component's generator or execution function. Kalasim Execution Model","title":"Event Queue"},{"location":"basics/#execution-order","text":"In the real world, events often appear to happen at the same time . However, in fact events always occur at slightly differing times. Clearly the notion of same depends on the resolution of the used time axis. Birthdays will happen on the same day whereas the precise birth events will always differ in absolute timing. Even if real-world processes may run \"in parallel\", a simulation is processed sequentially and deterministically. With the same random-generator initialization, you will always get the same simulation results when running your simulation multiple times. Although, kalasim supports double-precision to schedule events, events will inevitably arise that are scheduled for the same time . Because of its single-threaded, deterministic execution model (like most DES frameworks), kalasim processes events sequentially \u2013 one after another. If two events are scheduled at the same time, the one scheduled first will also be the processed first (FIFO). As pointed out in Ucar, 2019 , there are many situations where simultaneous events may occur in simulation. To provide a well-defined behavior in such situations, process interaction methods (namely wait , request , activate and reschedule ) support a priority parameter. With priority which is 0 by default, it is possible to sort a component before or after other components, scheduled for the same time. Events with higher priority are executed first in situations where multiple events are scheduled for the same simulation time. In contrast to other DSE implementations, the user does not need to make sure that a resource release() is prioritized over a simultaneous request() . The engine will automatically reschedule tasks accordingly. So the key points to recall are Real world events may appear to happen at the same discretized simulation time Simulation events are processed one after another, even if they are scheduled for the same time Race-conditions between events can be avoided by setting a priority","title":"Execution Order"},{"location":"basics/#simulation-runtime-environment","text":"The execution context of a kalasim simulation is an Environment , which can be created with val env : Environment = createSimulation ( enableConsoleLogger = true ){ // Create components in here Car () // To disambiguate between multiple simulations, provide a reference to the koin context // The koin argument can be omitted if just a single simulation is being used Component ( koin = getKoin ()) }. run ( 5.0 ) To configure references, an Environment can also be instantiated by configuring dependencies first with configureEnvironment . Check out the Traffic example to learn how that works.","title":"Simulation Runtime Environment"},{"location":"basics/#dependency-injection","text":"Kalasim is building on top of koin to inject dependencies between elements of a simulation. As pragmatic approach, it is using a global application context by default, but does allow for parallel simulations with Koin Isolation . For a simulation example with multiple Environment see https://github.com/holgerbrandl/kalasim/tree/master/src/test/kotlin/org/kalasim/test/EnvTests.kt Koin does not allow injecting simple types. To inject simple variables, consider using a wrapper class. Example ////SimpleInject.kts import org.kalasim.Component import org.kalasim.add import org.kalasim.configureEnvironment data class Counter ( var value : Int ) class Something ( val counter : Counter ) : Component () { override fun process () = sequence < Component > { counter . value ++ } } configureEnvironment { add { Counter ( 0 ) } add { Something ( get ()) } }. run ( 10 ) For details about how to use lazy injection with inject<T>() and instance retrieval with get<T>() see koin reference . Examples Traffic Car Wash Gas Station","title":"Dependency Injection"},{"location":"basics/#randomness-distributions","text":"Experimentation in a simulation context relates to large part to controlling randomness. Here, this is achieved by using probabilistic distributions which are internally backed by apache-commons-math . A simulation always allows deterministic execution while still supporting pseudo-random sampling. When creating a new simulation environment , the user can provide a random seed which is internally resolved to a random generator to be used in process definitions. createSimulation ( randomSeed = 123 ){ val randomGenerator = rg // which is resolved by Environment receiver } With random generator, the following distributions are supported out of the box (with common defaults where possible) as extension functions on Component and Environment : uniform(lower=0, upper=1) discreteUniform(lower, upper) exponential(mean) normal(mean=0, sd=1) Whenever, distributions are needed in method signatures in kalasim , the more general interface org.apache.commons.math3.distribution.RealDistribution is being used to support a much wider variety of distributions if needed. So we can also use other implementations as well. For example ComponentGenerator ( iat = NakagamiDistribution ( 1 , 0.3 )){ Customer () } The API also include some convenience wrappers to provide fixed values for argument of RealDistribution . E.g. consider the time until a request is considered as failed: val dist = 3. asConstantDist () ComponentGenerator ( iat = dist ){ Customer () } Here, 3 is converted into a org.apache.commons.math3.distribution.ConstantRealDistribution .","title":"Randomness &amp; Distributions"},{"location":"changes/","text":"Kalasim Release History v0.7 Not released yet Major enhancements * Dramatically improved simulation performance * Introduced AssertMode s ( Full , Light (default), None ) to enable/disable internal consistency checks. This will optimize performance by another ~20% (depending on simulation logic) * Improved event logging API Minor enhancements * Allow for runtime reconfiguration of ClockSync to enable adjustable simulation speed Breaking changes * changes Component.now and Environment.now to new value class TickTime for better type safety * Simplified ClockSync API by removing redundant speedUp parameter v0.6 Released 2021-02-12 -> Updated to v0.6.6 on 2021-05-05 Major Enhancements Added selectResource() to select from resources with policy val doctors = List ( 3 ) { Resource () } val selected = selectResource ( doctors , policy = SHORTEST_QUEUE ) New suspending batch interaction to group an entity stream into blocks val queue = ComponentQueue < Customer > () val batchLR : List < Customer > = batch ( queue , 4 , timeout = 10 ) Added option to configure a tick to wall time transformer createSimulation { tickTransform = OffsetTransform ( Instant . now (), TimeUnit . MINUTES ) run ( Duration . ofMinutes ( 90 ). asTicks ()) println ( asWallTime ( now )) } Added lifecycle records to streamline component state analyses Changed ComponentGenerator to allow generating arbitrary types (and not just Component s) ComponentGenerator ( uniform ( 0 , 1 )){ counter -> \"smthg no ${ counter } \" } Added forceStart to ComponentGenerator to define if an arrival should be happen when it is activated for the first time Changed scheduling priority from Int to inline class Priority (with defaults NORMAL , HIGH , LOW ) in all interaction methods for more typesafe API Started bundled simulations for adhoc experimentation and demonstration by adding M/M/1 queue MM1Queue Added support for pluggable visualization backend. Currently kravis and lets-plot are supported. For jupyter-notebook examples mm1-queue analysis // simply toggle backend by package import import org.kalasim.plot.letsplot.display // or //import org.kalasim.plot.kravis.display MM1Queue (). apply { run ( 100 ) server . claimedMonitor . display () } New Example: \"The ferryman\" New Example: Office Tower v0.5 Released 2021-01-12 Major Enhancements Added first jupyter notebook example New depletable resource type New statistical distributions API New more structured event logging. See user manual Implemented support for real-time simulations New example Dining Philosophers New example Movie Theater New API to add dependencies in simulation context using dependency {} Notable Fixes Fixed failAt in request v0.4 Released 2021-01-03 Major Enhancements Implemented interrupt interaction Reworked documentation and examples Implemented standby Implement disable/enable for monitors Yield internally, to simplify process definitions // before object : Component () { override fun process () = sequence { yield ( hold ( 1.0 )) } } // now object : Component () { override fun process () = sequence { hold ( 1.0 ) } } Made scheduledTime nullable: Replaced scheduledTime = Double.MAX_VALUE with null where possible to provide better mental execution model Provide lambda parameter to enable auto-releasing of resources // before object : Component () { override fun process () = sequence { request ( r ) hold ( 1 ) release ( r ) } } // now object : Component () { override fun process () = sequence { request ( r ){ hold ( 1 ) } } } Implemented Environment.toString to provide json description Various bug-fixes v0.3 Reimplemented monitors Continued salabim core API reimplementation Fixed: Decouple simulation with different koin application contxts v0.2 Reimplement core salabim examples in kotlin Port all salabim examples Started MkDocs manual v0.1 Reimplement salabim's main component lifecycle Add timing API","title":"What's New"},{"location":"changes/#kalasim-release-history","text":"","title":"Kalasim Release History"},{"location":"changes/#v07","text":"Not released yet Major enhancements * Dramatically improved simulation performance * Introduced AssertMode s ( Full , Light (default), None ) to enable/disable internal consistency checks. This will optimize performance by another ~20% (depending on simulation logic) * Improved event logging API Minor enhancements * Allow for runtime reconfiguration of ClockSync to enable adjustable simulation speed Breaking changes * changes Component.now and Environment.now to new value class TickTime for better type safety * Simplified ClockSync API by removing redundant speedUp parameter","title":"v0.7"},{"location":"changes/#v06","text":"Released 2021-02-12 -> Updated to v0.6.6 on 2021-05-05 Major Enhancements Added selectResource() to select from resources with policy val doctors = List ( 3 ) { Resource () } val selected = selectResource ( doctors , policy = SHORTEST_QUEUE ) New suspending batch interaction to group an entity stream into blocks val queue = ComponentQueue < Customer > () val batchLR : List < Customer > = batch ( queue , 4 , timeout = 10 ) Added option to configure a tick to wall time transformer createSimulation { tickTransform = OffsetTransform ( Instant . now (), TimeUnit . MINUTES ) run ( Duration . ofMinutes ( 90 ). asTicks ()) println ( asWallTime ( now )) } Added lifecycle records to streamline component state analyses Changed ComponentGenerator to allow generating arbitrary types (and not just Component s) ComponentGenerator ( uniform ( 0 , 1 )){ counter -> \"smthg no ${ counter } \" } Added forceStart to ComponentGenerator to define if an arrival should be happen when it is activated for the first time Changed scheduling priority from Int to inline class Priority (with defaults NORMAL , HIGH , LOW ) in all interaction methods for more typesafe API Started bundled simulations for adhoc experimentation and demonstration by adding M/M/1 queue MM1Queue Added support for pluggable visualization backend. Currently kravis and lets-plot are supported. For jupyter-notebook examples mm1-queue analysis // simply toggle backend by package import import org.kalasim.plot.letsplot.display // or //import org.kalasim.plot.kravis.display MM1Queue (). apply { run ( 100 ) server . claimedMonitor . display () } New Example: \"The ferryman\" New Example: Office Tower","title":"v0.6"},{"location":"changes/#v05","text":"Released 2021-01-12 Major Enhancements Added first jupyter notebook example New depletable resource type New statistical distributions API New more structured event logging. See user manual Implemented support for real-time simulations New example Dining Philosophers New example Movie Theater New API to add dependencies in simulation context using dependency {} Notable Fixes Fixed failAt in request","title":"v0.5"},{"location":"changes/#v04","text":"Released 2021-01-03 Major Enhancements Implemented interrupt interaction Reworked documentation and examples Implemented standby Implement disable/enable for monitors Yield internally, to simplify process definitions // before object : Component () { override fun process () = sequence { yield ( hold ( 1.0 )) } } // now object : Component () { override fun process () = sequence { hold ( 1.0 ) } } Made scheduledTime nullable: Replaced scheduledTime = Double.MAX_VALUE with null where possible to provide better mental execution model Provide lambda parameter to enable auto-releasing of resources // before object : Component () { override fun process () = sequence { request ( r ) hold ( 1 ) release ( r ) } } // now object : Component () { override fun process () = sequence { request ( r ){ hold ( 1 ) } } } Implemented Environment.toString to provide json description Various bug-fixes","title":"v0.4"},{"location":"changes/#v03","text":"Reimplemented monitors Continued salabim core API reimplementation Fixed: Decouple simulation with different koin application contxts","title":"v0.3"},{"location":"changes/#v02","text":"Reimplement core salabim examples in kotlin Port all salabim examples Started MkDocs manual","title":"v0.2"},{"location":"changes/#v01","text":"Reimplement salabim's main component lifecycle Add timing API","title":"v0.1"},{"location":"component/","text":"Component Components are the key elements of a simulation. Components can be either in data or an active lifecycle state. An active component has one or more process descriptions and is activated at some point of time. We can transition a data component to active with activate() . An active component can become DATA either with a cancel() or by reaching the end of a process method. It is easy to create a data component by: val component = Component () Data components may be placed in a queue. This component will not be activated as there is no associated process method. In order to make an active component it is necessary to first define a class. There has to be at least one sequence generator method, normally called process : class Ship: Component(){ override fun process() = sequence { ... yield(...) ... } } Normally, the process will contain at least one yield statement. But that's not a requirement. Typically, the user must not use yield directly, but rather the provided process interaction methods. Creation and activation can be combined by making a new instance of the class: val ship1 = Ship () val ship2 = Ship () val ship3 = Ship () This causes three Ships to be created and to start them at Sim.process(). The ships will be named automatically Ship.0 unless a name is provided. If no process method is found for Ship , the ship will be a data component. In that case, it may become active by means of an activate() statement: ////CraneProcess.kts import org.kalasim.Component import org.kalasim.ProcessPointer import org.kalasim.createSimulation class Crane ( process : ProcessPointer? = Component :: process ) : Component ( process = process ) { fun unload () = sequence < Component > { // yield ... } } createSimulation { val crane1 = Crane () crane1 . activate ( process = Crane :: unload ) // conceptually, the API supports also process definition at instantiation. Crane ( process = Crane :: unload ) } Effectively, creation and start of crane1 and crane2 is the same. In most practical scenarios, the process parameter is omitted in the method signature. Although not very common, it is possible to activate a component at a certain time or with a specified delay: ship1 . activate ( at = 100 ) ship2 . activate ( delay = 50 ) Creation of a component Although it is possible to create a component directly with val x = Component() , this makes it very hard to make that component into an active component, because there's no process method. So, nearly always we define our simulation entities by extending org.kalasim.Component and by providing a process definition which details out the component's life cycle: class Car : Component (){ override fun process () = sequence { hold ( 1 ) // or whatever } } If we then say val car = Car() , a component is created, and it activated from process. This process is nearly always, but not necessarily a generator method (i.e. it has at least one yield statement). The result is that car is put on the future event list (for time now ) and when it's its turn, the component becomes CURRENT . It is also possible to set a time at which the component (car) becomes active, like val car = Car(at=10) . This requires an additional constructor argument to be passed on to Component as in class Car(at:Number): Component(delay=at) . Instead of starting at process, the component may be initialized to start at another (generator) method, like car=Car(process=Car::wash) . Finally, if there is a process method, you can disable the automatic activation (i.e. make it a data component), by specifying process = null . If there is no process method, and process= is not given, the component will be a data component. Lifecycle A component is always in one of the following states modelled by org.kalasim.ComponentState : CURRENT - The component's process is currently being executed by the event queue SCHEDULED - The component is scheduled for future execution PASSIVE - The component is idle REQUESTING - The component is waiting for a resource requirement to be met WAITING - The component is waiting for a state predicate to be met STANDBY - The component was put on standby INTERRUPTED - The component was interrupted DATA - The component is non of the active states above. Components without a process definition are always in this state. A component's status is automatically tracked in the status level monitor component.statusMonitor . Thus, it possible to check how long a component has been in a particuar state with val passiveDuration = component . statusMonitor [ ComponentState . PASSIVE ] It is possible to print a histogram with all the statuses a component has been in with component . statusMonitor . printHistogram () Accumulated times in a particular state can be obtained with summed() and be printed to console or displayed with the selected graphics backend val timeInEachState = component . statusMonitor . summed () timeInEachState . printConsole () timeInEachState . display () Process Interaction The scheme below shows how interaction relate to component state transitions: from/to data current scheduled passive requesting waiting standby interrupted data activate 1 activate current process end yield hold yield passivate yield request yield wait yield standby . yield cancel yield activate scheduled cancel next event hold passivate request wait standby interrupt . activate passive cancel activate 1 activate request wait standby interrupt . hold 2 requesting cancel claim honor activate 3 passivate request wait standby interrupt . time out activate 4 waiting cancel wait honor activate 5 passivate wait wait standby interrupt . timeout activate 6 standby cancel next event activate passivate request wait interrupt interrupted cancel resume 7 resume 7 resume 7 resume 7 resume 7 interrupt 8 . activate passivate request wait standby Via scheduled() Not recommended With keepRequest = false (default) With keepRequest = true . This allows to set a new time out With keepWait = false (default) With keepWait = true . This allows to set a new timeout State at time of interrupt Increases the interruptLevel activate Activate will schedule execution at the specified time. If you do not specify a process, the current process will scheduled for continuation . If a process argument is provided, the process will be started (or restarted if it is equal to the currently active process). val car0 = Car ( process = null ) // data component car0 . activate () // activate @ process if exists, otherwise error val car1 = Car ( process = null ) // data component car1 . activate ( process = null ) // activate @ wash If the component to be activated is DATA , unless provided with process the default Component::process will be scheduled at the specified time. If the component to be activated is PASSIVE , the component will be activated at the specified time. If the component to be activated is SCHEDULED , the component will get a new scheduled time. If the component to be activated is REQUESTING , the request will be terminated, the attribute failed set, and the component will become scheduled. If keep_request=True is specified, only the fail_at will be updated, and the component will stay requesting. If the component to be activated is WAITING , the wait will be terminated, the attribute failed set, and the component will become scheduled. If keepWait=true is specified, only the failAt will be updated, and the component will stay waiting. If the component to be activated is STANDBY , the component will get a new scheduled time and become scheduled. If the component is INTERRUPTED , the component will be activated at the specified time. Note It is not possible to activate the CURRENT component, and kalasim will throw an error in this situation. The effect of a \"self\"-activate would be that the component becomes scheduled, thus this is essentially equivalent to the preferred hold method, so please use hold instead. In rare situations processes need to be restarted. If so, use yield for activation and provide the process pointer yield(activate(process = Component::process)) which will bypass the internal requirement that the activated component mustt not be CURRENT . hold Hold is the way to make a - usually current - component scheduled . If the component is CURRENT , it will suspend execution internally, and the component becomes scheduled for the specified time If the component to be held is passive, the component becomes scheduled for the specified time. If the component to be held is scheduled, the component will be rescheduled for the specified time, thus essentially the same as activate. If the component to be held is standby, the component becomes scheduled for the specified time. If the component to be activated is requesting, the request will be terminated, the attribute failed set and the component will become scheduled. It is recommended to use the more versatile activate method. If the component to be activated is waiting, the wait will be terminated, the attribute failed set and the component will become scheduled. It is recommended to use the more versatile activate method. If the component is interrupted, the component will be activated at the specified time. passivate Passivate is the way to make a - usually current - component passive . This is essentially the same as scheduling for time=inf. If the component to be passivated is CURRENT , the component becomes passive, and it will suspend execution internally. If the component to be passivated is passive , the component remains passive . If the component to be passivated is scheduled , the component becomes passive . If the component to be held is standby , the component becomes passive . If the component to be activated is requesting, the request will be terminated, the attribute failed set and the component becomes passive. It is recommended to use the more versatile activate method. If the component to be activated is waiting, the wait will be terminated, the attribute failed set and the component becomes passive. It is recommended to use the more versatile activate method. If the component is interrupted, the component becomes passive. cancel Cancel has the effect that the component becomes a data component. If the component to be cancelled is CURRENT , it will suspend execution internally. If the component to be cancelled is passive , scheduled, interrupted or standby, the component becomes a data component. If the component to be cancelled is requesting , the request will be terminated, the attribute failed set, and the component becomes a data component. If the component to be cancelled is waiting, the wait will be terminated, the attribute failed set and the component becomes a data component. Examples Bank Office with Reneging standby Standby has the effect that the component will be triggered on the next simulation event. If the component is CURRENT , it will suspend execution internally Although theoretically possible, it is not recommended to use standby for non current components. If needed to do so, the pattern to provide the correct receiver is with(nonCurrent){ standby() } Not allowed for DATA components or main Examples Bank Office with Standby request Request has the effect that the component will check whether the requested quantity from a resource is available. It is possible to check for multiple availability of a certain quantity from several resources. Instead of checking for all of number of resources, it is also possible to check for any of a number of resources, by setting the oneOf parameter to true . By default, there is no limit on the time to wait for the resource(s) to become available. However, it is possible to set a time with failAt at which the condition has to be met. If that failed, the component becomes CURRENT at the given point of time. This is also known as reneging . If the component is canceled, activated, passivated, interrupted or held the failed flag will be set as well. If the component is CURRENT , it will suspend execution internally Although theoretically possible it is not recommended to use request for non current components. If needed to do so, the pattern to provide the correct receiver is with(nonCurrent){ request(r) } A component can also actively renege a pending request by calling release(resource) . See Bank3ClerksRenegingResources for an example (as well as Bank3ClerksReneging Bank3ClerksRenegingState for other supported reneging modes). wait Wait has the effect that the component will check whether the value of a state meets a given condition. It is possible to check for multiple states. By default, there is no limit on the time to wait for the condition(s) to be met. However, it is possible to set a time with failAt at which the condition has to be met. If that failed, the component becomes CURRENT at the given point of time. The code should then check whether the wait had failed. That can be checked with the Component.failed property. If the component is canceled , activated , passivated , interrupted or held the failed flag will be set as well. If the component is CURRENT , it will suspend execution internally Although theoretically possible it is not recommended to use wait for non current components. If needed to do so, the pattern to provide the correct receiver is with(nonCurrent){ wait() } Examples Gas Station interrupt With interrupt components that are not current or data can be temporarily be interrupted. Once a resume is called for the component, the component will continue (for scheduled with the remaining time, for waiting or requesting possibly with the remaining fail_at duration). Examples Machine Parts Usage of process interaction methods within a function or method There is a way to put process interaction statement in another function or method. This requires a slightly different way than just calling the method. As an example, let's assume that we want a method that holds a component for a number of minutes and that the time unit is actually seconds. So we need a method to wait 60 times the given parameter. We start with a not so elegant solution: object : Component () { override fun process () = sequence < Component > { hold ( 5.0 ) hold ( 5.0 ) } } Now we just add a method holdMinutes . Direct calling holdMinutes is not possible. Instead, we have to define an extension function on SequenceScope<Component> : object : Component () { override fun process () = sequence { holdMinutes () holdMinutes () } private suspend fun SequenceScope < Component > . holdMinutes () { hold ( 5.0 ) } } All process interaction statements including passivate , request and wait can be used that way! So remember if the method contains a yield statement (technically speaking iss a generator method), it should be called with from an extension function. Component Generator Since creation/generation of components is a very common element of most simulations, there is a dedicated utility called ComponentGenerator to do so ComponentGenerator ( iat = exponential ( lambda , rg )) { Customer () } It requires 2 main parameters 1. a builder pattern 2. an inter-arrival distribution See here for a complete listing of supported arguments. Examples Car Wash Gas Station ATM Queue Queue Kalasim builds on top of the JVM's PriorityQueue to model waiting lines etc. Conceptual our implementation is very similar to salabim 's queue . A typical use case would be a generator process (material, customers, etc.) that is consumed by other components. By definition, a generator is a Component that contains at least one yield in its process definition. In the following example a generator is creating new Customer s which are entering a waiting line Queue . This queue is consumed by a clerk which take one customer at a time and goes on hold for processing. See here for the complete implementation. sequenceDiagram EventLoop->>CustomerGenerator: Continue generator process CustomerGenerator->>Customer: Create new Customer CustomerGenerator-->>EventLoop: Reschedule for later Customer->>Queue: Enter waiting line Clerk->>Queue: Pull next customer Clerk-->>EventLoop: hold vor n time units for processing Examples ATM Queue Batching Queues can be consumed in a batched manner using the batch() . See \"The Ferryman\" for a worked out example and its API documentation.","title":"Components"},{"location":"component/#component","text":"Components are the key elements of a simulation. Components can be either in data or an active lifecycle state. An active component has one or more process descriptions and is activated at some point of time. We can transition a data component to active with activate() . An active component can become DATA either with a cancel() or by reaching the end of a process method. It is easy to create a data component by: val component = Component () Data components may be placed in a queue. This component will not be activated as there is no associated process method. In order to make an active component it is necessary to first define a class. There has to be at least one sequence generator method, normally called process : class Ship: Component(){ override fun process() = sequence { ... yield(...) ... } } Normally, the process will contain at least one yield statement. But that's not a requirement. Typically, the user must not use yield directly, but rather the provided process interaction methods. Creation and activation can be combined by making a new instance of the class: val ship1 = Ship () val ship2 = Ship () val ship3 = Ship () This causes three Ships to be created and to start them at Sim.process(). The ships will be named automatically Ship.0 unless a name is provided. If no process method is found for Ship , the ship will be a data component. In that case, it may become active by means of an activate() statement: ////CraneProcess.kts import org.kalasim.Component import org.kalasim.ProcessPointer import org.kalasim.createSimulation class Crane ( process : ProcessPointer? = Component :: process ) : Component ( process = process ) { fun unload () = sequence < Component > { // yield ... } } createSimulation { val crane1 = Crane () crane1 . activate ( process = Crane :: unload ) // conceptually, the API supports also process definition at instantiation. Crane ( process = Crane :: unload ) } Effectively, creation and start of crane1 and crane2 is the same. In most practical scenarios, the process parameter is omitted in the method signature. Although not very common, it is possible to activate a component at a certain time or with a specified delay: ship1 . activate ( at = 100 ) ship2 . activate ( delay = 50 )","title":"Component"},{"location":"component/#creation-of-a-component","text":"Although it is possible to create a component directly with val x = Component() , this makes it very hard to make that component into an active component, because there's no process method. So, nearly always we define our simulation entities by extending org.kalasim.Component and by providing a process definition which details out the component's life cycle: class Car : Component (){ override fun process () = sequence { hold ( 1 ) // or whatever } } If we then say val car = Car() , a component is created, and it activated from process. This process is nearly always, but not necessarily a generator method (i.e. it has at least one yield statement). The result is that car is put on the future event list (for time now ) and when it's its turn, the component becomes CURRENT . It is also possible to set a time at which the component (car) becomes active, like val car = Car(at=10) . This requires an additional constructor argument to be passed on to Component as in class Car(at:Number): Component(delay=at) . Instead of starting at process, the component may be initialized to start at another (generator) method, like car=Car(process=Car::wash) . Finally, if there is a process method, you can disable the automatic activation (i.e. make it a data component), by specifying process = null . If there is no process method, and process= is not given, the component will be a data component.","title":"Creation of a component"},{"location":"component/#lifecycle","text":"A component is always in one of the following states modelled by org.kalasim.ComponentState : CURRENT - The component's process is currently being executed by the event queue SCHEDULED - The component is scheduled for future execution PASSIVE - The component is idle REQUESTING - The component is waiting for a resource requirement to be met WAITING - The component is waiting for a state predicate to be met STANDBY - The component was put on standby INTERRUPTED - The component was interrupted DATA - The component is non of the active states above. Components without a process definition are always in this state. A component's status is automatically tracked in the status level monitor component.statusMonitor . Thus, it possible to check how long a component has been in a particuar state with val passiveDuration = component . statusMonitor [ ComponentState . PASSIVE ] It is possible to print a histogram with all the statuses a component has been in with component . statusMonitor . printHistogram () Accumulated times in a particular state can be obtained with summed() and be printed to console or displayed with the selected graphics backend val timeInEachState = component . statusMonitor . summed () timeInEachState . printConsole () timeInEachState . display ()","title":"Lifecycle"},{"location":"component/#process-interaction","text":"The scheme below shows how interaction relate to component state transitions: from/to data current scheduled passive requesting waiting standby interrupted data activate 1 activate current process end yield hold yield passivate yield request yield wait yield standby . yield cancel yield activate scheduled cancel next event hold passivate request wait standby interrupt . activate passive cancel activate 1 activate request wait standby interrupt . hold 2 requesting cancel claim honor activate 3 passivate request wait standby interrupt . time out activate 4 waiting cancel wait honor activate 5 passivate wait wait standby interrupt . timeout activate 6 standby cancel next event activate passivate request wait interrupt interrupted cancel resume 7 resume 7 resume 7 resume 7 resume 7 interrupt 8 . activate passivate request wait standby Via scheduled() Not recommended With keepRequest = false (default) With keepRequest = true . This allows to set a new time out With keepWait = false (default) With keepWait = true . This allows to set a new timeout State at time of interrupt Increases the interruptLevel","title":"Process Interaction"},{"location":"component/#activate","text":"Activate will schedule execution at the specified time. If you do not specify a process, the current process will scheduled for continuation . If a process argument is provided, the process will be started (or restarted if it is equal to the currently active process). val car0 = Car ( process = null ) // data component car0 . activate () // activate @ process if exists, otherwise error val car1 = Car ( process = null ) // data component car1 . activate ( process = null ) // activate @ wash If the component to be activated is DATA , unless provided with process the default Component::process will be scheduled at the specified time. If the component to be activated is PASSIVE , the component will be activated at the specified time. If the component to be activated is SCHEDULED , the component will get a new scheduled time. If the component to be activated is REQUESTING , the request will be terminated, the attribute failed set, and the component will become scheduled. If keep_request=True is specified, only the fail_at will be updated, and the component will stay requesting. If the component to be activated is WAITING , the wait will be terminated, the attribute failed set, and the component will become scheduled. If keepWait=true is specified, only the failAt will be updated, and the component will stay waiting. If the component to be activated is STANDBY , the component will get a new scheduled time and become scheduled. If the component is INTERRUPTED , the component will be activated at the specified time. Note It is not possible to activate the CURRENT component, and kalasim will throw an error in this situation. The effect of a \"self\"-activate would be that the component becomes scheduled, thus this is essentially equivalent to the preferred hold method, so please use hold instead. In rare situations processes need to be restarted. If so, use yield for activation and provide the process pointer yield(activate(process = Component::process)) which will bypass the internal requirement that the activated component mustt not be CURRENT .","title":"activate"},{"location":"component/#hold","text":"Hold is the way to make a - usually current - component scheduled . If the component is CURRENT , it will suspend execution internally, and the component becomes scheduled for the specified time If the component to be held is passive, the component becomes scheduled for the specified time. If the component to be held is scheduled, the component will be rescheduled for the specified time, thus essentially the same as activate. If the component to be held is standby, the component becomes scheduled for the specified time. If the component to be activated is requesting, the request will be terminated, the attribute failed set and the component will become scheduled. It is recommended to use the more versatile activate method. If the component to be activated is waiting, the wait will be terminated, the attribute failed set and the component will become scheduled. It is recommended to use the more versatile activate method. If the component is interrupted, the component will be activated at the specified time.","title":"hold"},{"location":"component/#passivate","text":"Passivate is the way to make a - usually current - component passive . This is essentially the same as scheduling for time=inf. If the component to be passivated is CURRENT , the component becomes passive, and it will suspend execution internally. If the component to be passivated is passive , the component remains passive . If the component to be passivated is scheduled , the component becomes passive . If the component to be held is standby , the component becomes passive . If the component to be activated is requesting, the request will be terminated, the attribute failed set and the component becomes passive. It is recommended to use the more versatile activate method. If the component to be activated is waiting, the wait will be terminated, the attribute failed set and the component becomes passive. It is recommended to use the more versatile activate method. If the component is interrupted, the component becomes passive.","title":"passivate"},{"location":"component/#cancel","text":"Cancel has the effect that the component becomes a data component. If the component to be cancelled is CURRENT , it will suspend execution internally. If the component to be cancelled is passive , scheduled, interrupted or standby, the component becomes a data component. If the component to be cancelled is requesting , the request will be terminated, the attribute failed set, and the component becomes a data component. If the component to be cancelled is waiting, the wait will be terminated, the attribute failed set and the component becomes a data component. Examples Bank Office with Reneging","title":"cancel"},{"location":"component/#standby","text":"Standby has the effect that the component will be triggered on the next simulation event. If the component is CURRENT , it will suspend execution internally Although theoretically possible, it is not recommended to use standby for non current components. If needed to do so, the pattern to provide the correct receiver is with(nonCurrent){ standby() } Not allowed for DATA components or main Examples Bank Office with Standby","title":"standby"},{"location":"component/#request","text":"Request has the effect that the component will check whether the requested quantity from a resource is available. It is possible to check for multiple availability of a certain quantity from several resources. Instead of checking for all of number of resources, it is also possible to check for any of a number of resources, by setting the oneOf parameter to true . By default, there is no limit on the time to wait for the resource(s) to become available. However, it is possible to set a time with failAt at which the condition has to be met. If that failed, the component becomes CURRENT at the given point of time. This is also known as reneging . If the component is canceled, activated, passivated, interrupted or held the failed flag will be set as well. If the component is CURRENT , it will suspend execution internally Although theoretically possible it is not recommended to use request for non current components. If needed to do so, the pattern to provide the correct receiver is with(nonCurrent){ request(r) } A component can also actively renege a pending request by calling release(resource) . See Bank3ClerksRenegingResources for an example (as well as Bank3ClerksReneging Bank3ClerksRenegingState for other supported reneging modes).","title":"request"},{"location":"component/#wait","text":"Wait has the effect that the component will check whether the value of a state meets a given condition. It is possible to check for multiple states. By default, there is no limit on the time to wait for the condition(s) to be met. However, it is possible to set a time with failAt at which the condition has to be met. If that failed, the component becomes CURRENT at the given point of time. The code should then check whether the wait had failed. That can be checked with the Component.failed property. If the component is canceled , activated , passivated , interrupted or held the failed flag will be set as well. If the component is CURRENT , it will suspend execution internally Although theoretically possible it is not recommended to use wait for non current components. If needed to do so, the pattern to provide the correct receiver is with(nonCurrent){ wait() } Examples Gas Station","title":"wait"},{"location":"component/#interrupt","text":"With interrupt components that are not current or data can be temporarily be interrupted. Once a resume is called for the component, the component will continue (for scheduled with the remaining time, for waiting or requesting possibly with the remaining fail_at duration). Examples Machine Parts","title":"interrupt"},{"location":"component/#usage-of-process-interaction-methods-within-a-function-or-method","text":"There is a way to put process interaction statement in another function or method. This requires a slightly different way than just calling the method. As an example, let's assume that we want a method that holds a component for a number of minutes and that the time unit is actually seconds. So we need a method to wait 60 times the given parameter. We start with a not so elegant solution: object : Component () { override fun process () = sequence < Component > { hold ( 5.0 ) hold ( 5.0 ) } } Now we just add a method holdMinutes . Direct calling holdMinutes is not possible. Instead, we have to define an extension function on SequenceScope<Component> : object : Component () { override fun process () = sequence { holdMinutes () holdMinutes () } private suspend fun SequenceScope < Component > . holdMinutes () { hold ( 5.0 ) } } All process interaction statements including passivate , request and wait can be used that way! So remember if the method contains a yield statement (technically speaking iss a generator method), it should be called with from an extension function.","title":"Usage of process interaction methods within a function or method"},{"location":"component/#component-generator","text":"Since creation/generation of components is a very common element of most simulations, there is a dedicated utility called ComponentGenerator to do so ComponentGenerator ( iat = exponential ( lambda , rg )) { Customer () } It requires 2 main parameters 1. a builder pattern 2. an inter-arrival distribution See here for a complete listing of supported arguments. Examples Car Wash Gas Station ATM Queue","title":"Component Generator"},{"location":"component/#queue","text":"Kalasim builds on top of the JVM's PriorityQueue to model waiting lines etc. Conceptual our implementation is very similar to salabim 's queue . A typical use case would be a generator process (material, customers, etc.) that is consumed by other components. By definition, a generator is a Component that contains at least one yield in its process definition. In the following example a generator is creating new Customer s which are entering a waiting line Queue . This queue is consumed by a clerk which take one customer at a time and goes on hold for processing. See here for the complete implementation. sequenceDiagram EventLoop->>CustomerGenerator: Continue generator process CustomerGenerator->>Customer: Create new Customer CustomerGenerator-->>EventLoop: Reschedule for later Customer->>Queue: Enter waiting line Clerk->>Queue: Pull next customer Clerk-->>EventLoop: hold vor n time units for processing Examples ATM Queue","title":"Queue"},{"location":"component/#batching","text":"Queues can be consumed in a batched manner using the batch() . See \"The Ferryman\" for a worked out example and its API documentation.","title":"Batching"},{"location":"event_log/","text":"Event Log To analyze a simulation, you may want to monitor entity creation and process progression. You may also want to trace which process caused an event or which processes waited for an event. kalasim is collecting these data for all simulation entities and in also within its interaction model . The event log is modelled as a sequence of org.kalasim.Event s that be consumed with org.kalasim.EventListener . We follow a classical publish-subscribe pattern here, where users can easily attach different monitoring backends such as files, databases, or in-place-analytics. createSimulation { addEventListener { it : Event -> println ( it )} } Event listener implementations typically do not consume all events but filter for specific types or simulation entities. This filtering can be implemented in the listener or by providing a filter class MyEventLister : EventListener { override fun consume ( event : Event ) { println ( event ) } override val filter = EventFilter { it is ResourceEvent } } Users typically create custom simulation events and corresponding listeners to consume state changes for analysis and visualization. import org.kalasim.Component import org.kalasim.Event import org.kalasim.createSimulation createSimulation { addEventListener { println ( it )} class MyEvent ( msg : String ) : Event ( now ()) object : Component (){ // override fun process() = sequence<Component> { // log(MyEvent(\"something magical happened\")) // } } } Console Logger There are a few provided event listeners, most notable the built-int console logger. With console logging being enabled, we get the following output (displayed as table for convenience): time current component component action info --------- ------------------------ ------------------------ ----------- ----------------------------- .00 main DATA create .00 main .00 Car.1 DATA create .00 Car.1 DATA activate .00 main CURRENT run +5.0 .00 Car.1 .00 Car.1 CURRENT hold +1.0 1.00 Car.1 CURRENT 1.00 Car.1 DATA ended 5.00 main Process finished with exit code 0 Console logging is not active by default as it would considerably slow down larger simulations, and but must be enabled when creating a simulation with createSimulation(enableConsoleLogger = true) Trace Collector Another built-in event listener is the trace collector, which simply records all events and puts them in a list for latter analysis. Events can also be accumulated by using traceCollector() For example to fetch all events related to resource requests we could filter by the corresponding event type ////EventCollector.kts import org.kalasim.* createSimulation ( enableConsoleLogger = true ) { val tc = traceCollector () tc . filter { it is InteractionEvent && it . source ?. name == \"foo\" } val claims = tc // . filterIsInstance < ResourceEvent > () . filter { it . type == ResourceEventType . CLAIMED } }. run ( 5.0 ) Asynchronous Processing Trace logs a suitable for standard kotlin collection processing. E.g. we could setup a coroutines channel for log events to be consumed asynchronously. ////LogChannelConsumer.kts package org.kalasim.examples.analysis import kotlinx.coroutines.GlobalScope import kotlinx.coroutines.channels.Channel import kotlinx.coroutines.flow.collect import kotlinx.coroutines.flow.filter import kotlinx.coroutines.flow.receiveAsFlow import kotlinx.coroutines.launch import org.kalasim.* class MyEventConsumer : EventListener { // think of it as a Non Blocking Queue val ordersChannel = Channel < Event > () override fun consume ( event : Event ) { GlobalScope . launch { ordersChannel . offer ( event ) } } } val tl = MyEventConsumer () // Start a log consumer GlobalScope . launch { tl . ordersChannel . receiveAsFlow (). filter { it is InteractionEvent && it . curComponent ?. name == \"ComponentGenerator.1\" }. collect { println ( it ) } } // create simulation with no default logging val sim = createSimulation { ComponentGenerator ( iat = 1. asDist ()) { Component ( \"Car. ${ it } \" ) } // add custom log consumer addEventListener ( tl ) // run the simulation run ( 100 ) } In the example, we can think of a channel as a pipe between two coroutines. For details see the great articlle Kotlin: Diving in to Coroutines and Channels . Tabular Interface A typesafe data-structure is usually the preferred for modelling. However, accessing data in a tabular format can also be helpful to enable statistical analyses. Enabled by krangl's Iterable<T>.asDataFrame() extension, we can transform records, events and simulation entities easily into tables. This also provides a semantic compatibility layer with other DES engines (such as simmer ), that are centered around tables for model analysis. We can apply such a transformation simulation Event s. For example, we can apply an instance filter to the recorded log to extract only log records relating to resource requests. These can be transformed and converted to a csv with just: // ... add your simulation here ... data class RequestRecord ( val requester : String , val timestamp : Double , val resource : String , val quantity : Double ) val tc = sim . get < TraceCollector > () val requests = tc . filterIsInstance < ResourceEvent > (). map { val amountDirected = ( if ( it . type == ResourceEventType . RELEASED ) - 1 else 1 ) * it . amount RequestRecord ( it . requester . name , it . time , it . resource . name , amountDirected ) } // transform data into data-frame (for visualization and stats) requests . asDataFrame (). writeCSV ( \"requests.csv\" ) The transformation step is optional, List<Event> can be transformed asDataFrame() directly. Events in Jupyter When working with jupyter, we can harvest the kernel's built-in rendering capabilities to render events. Note that we need to filter for specific event type to capture all attributes. For a fully worked out example see","title":"Event Log"},{"location":"event_log/#event-log","text":"To analyze a simulation, you may want to monitor entity creation and process progression. You may also want to trace which process caused an event or which processes waited for an event. kalasim is collecting these data for all simulation entities and in also within its interaction model . The event log is modelled as a sequence of org.kalasim.Event s that be consumed with org.kalasim.EventListener . We follow a classical publish-subscribe pattern here, where users can easily attach different monitoring backends such as files, databases, or in-place-analytics. createSimulation { addEventListener { it : Event -> println ( it )} } Event listener implementations typically do not consume all events but filter for specific types or simulation entities. This filtering can be implemented in the listener or by providing a filter class MyEventLister : EventListener { override fun consume ( event : Event ) { println ( event ) } override val filter = EventFilter { it is ResourceEvent } } Users typically create custom simulation events and corresponding listeners to consume state changes for analysis and visualization. import org.kalasim.Component import org.kalasim.Event import org.kalasim.createSimulation createSimulation { addEventListener { println ( it )} class MyEvent ( msg : String ) : Event ( now ()) object : Component (){ // override fun process() = sequence<Component> { // log(MyEvent(\"something magical happened\")) // } } }","title":"Event Log"},{"location":"event_log/#console-logger","text":"There are a few provided event listeners, most notable the built-int console logger. With console logging being enabled, we get the following output (displayed as table for convenience): time current component component action info --------- ------------------------ ------------------------ ----------- ----------------------------- .00 main DATA create .00 main .00 Car.1 DATA create .00 Car.1 DATA activate .00 main CURRENT run +5.0 .00 Car.1 .00 Car.1 CURRENT hold +1.0 1.00 Car.1 CURRENT 1.00 Car.1 DATA ended 5.00 main Process finished with exit code 0 Console logging is not active by default as it would considerably slow down larger simulations, and but must be enabled when creating a simulation with createSimulation(enableConsoleLogger = true)","title":"Console Logger"},{"location":"event_log/#trace-collector","text":"Another built-in event listener is the trace collector, which simply records all events and puts them in a list for latter analysis. Events can also be accumulated by using traceCollector() For example to fetch all events related to resource requests we could filter by the corresponding event type ////EventCollector.kts import org.kalasim.* createSimulation ( enableConsoleLogger = true ) { val tc = traceCollector () tc . filter { it is InteractionEvent && it . source ?. name == \"foo\" } val claims = tc // . filterIsInstance < ResourceEvent > () . filter { it . type == ResourceEventType . CLAIMED } }. run ( 5.0 )","title":"Trace Collector"},{"location":"event_log/#asynchronous-processing","text":"Trace logs a suitable for standard kotlin collection processing. E.g. we could setup a coroutines channel for log events to be consumed asynchronously. ////LogChannelConsumer.kts package org.kalasim.examples.analysis import kotlinx.coroutines.GlobalScope import kotlinx.coroutines.channels.Channel import kotlinx.coroutines.flow.collect import kotlinx.coroutines.flow.filter import kotlinx.coroutines.flow.receiveAsFlow import kotlinx.coroutines.launch import org.kalasim.* class MyEventConsumer : EventListener { // think of it as a Non Blocking Queue val ordersChannel = Channel < Event > () override fun consume ( event : Event ) { GlobalScope . launch { ordersChannel . offer ( event ) } } } val tl = MyEventConsumer () // Start a log consumer GlobalScope . launch { tl . ordersChannel . receiveAsFlow (). filter { it is InteractionEvent && it . curComponent ?. name == \"ComponentGenerator.1\" }. collect { println ( it ) } } // create simulation with no default logging val sim = createSimulation { ComponentGenerator ( iat = 1. asDist ()) { Component ( \"Car. ${ it } \" ) } // add custom log consumer addEventListener ( tl ) // run the simulation run ( 100 ) } In the example, we can think of a channel as a pipe between two coroutines. For details see the great articlle Kotlin: Diving in to Coroutines and Channels .","title":"Asynchronous Processing"},{"location":"event_log/#tabular-interface","text":"A typesafe data-structure is usually the preferred for modelling. However, accessing data in a tabular format can also be helpful to enable statistical analyses. Enabled by krangl's Iterable<T>.asDataFrame() extension, we can transform records, events and simulation entities easily into tables. This also provides a semantic compatibility layer with other DES engines (such as simmer ), that are centered around tables for model analysis. We can apply such a transformation simulation Event s. For example, we can apply an instance filter to the recorded log to extract only log records relating to resource requests. These can be transformed and converted to a csv with just: // ... add your simulation here ... data class RequestRecord ( val requester : String , val timestamp : Double , val resource : String , val quantity : Double ) val tc = sim . get < TraceCollector > () val requests = tc . filterIsInstance < ResourceEvent > (). map { val amountDirected = ( if ( it . type == ResourceEventType . RELEASED ) - 1 else 1 ) * it . amount RequestRecord ( it . requester . name , it . time , it . resource . name , amountDirected ) } // transform data into data-frame (for visualization and stats) requests . asDataFrame (). writeCSV ( \"requests.csv\" ) The transformation step is optional, List<Event> can be transformed asDataFrame() directly.","title":"Tabular Interface"},{"location":"event_log/#events-in-jupyter","text":"When working with jupyter, we can harvest the kernel's built-in rendering capabilities to render events. Note that we need to filter for specific event type to capture all attributes. For a fully worked out example see","title":"Events in Jupyter"},{"location":"examples/","text":"There's nothing more intriguing than a good example. To provide guidance we tried to categorize our examples by difficulty. Categorization is opinionated and just tries to pave an entry path into kalasim API. Simple Car - A single car, a driver, and red traffic light in the middle of the night. The thrilling landing page example but this time fully documented with an extensive code-walkthrough. Traffic - Car navigate through a simple traffic model with crossings and traffic-lights. Clearly, they need to refill, but there is just a limited number of slots as the gas station. Bank Office with 1 clerk - A classic queue, where customers arrive at a bank and need to be serviced Moderate Movie Theater - A big cinema, great movies. How long does it take before tickets are sold out? Car Wash - A car wash with limited throughput, and a continuous stream of new customers Machine Parts - A small shop-floor with multi-part machines, where all parts must be functional to avoid tool downtime Machine Shop - A day in a life of a busy maintenance engineer. Tools break and need to be repaired before they can continue operation The Ferryman - A wild river, one boat only, and a patient ferryman transporting batches of passengers across the body of water Elaborate ATM - The canonical queue model. Here, illustrated with a cash machine that needs to serve customers. Gas Station - A gas-station again, but this time the focus is on the station itself and how it struggls to get new petrol to serve hungry customers. Bank Office - A classical queue problem where customers need to be served. Here solved 4 times in different ways using different kalasim models. Dining Philosophers - Philosophers sit at a round table with bowls of spaghetti and try to eat. It ain't easy... Office Tower - A busy office building, where workers need to get from floor to floor using a limited number of elevators.","title":"Overview"},{"location":"faq/","text":"F.A.Q. Why rebuilding salabim ? Great question! Initial development was driven by curiosity about the salabim internals. Also, it lacked (arguably) a modern touch which made some of our use cases more tricky to implement. kalasim implements the great majority of salabim features as documented under https://www.salabim.org/manual/ including Components ComponentGenerator Queue Distributions (via apache-commons-math) Monitor Resource State Not planned Animation - which we believe should live in a separate codebase. Visualization in kalasim is detailed out in the visualization chapter . What (TF) is the meaning of kalasim ? We went through multiple iterations to come up with this great name: desimuk - {d}iscrete {e}vent {simu}lation with {k}otlin seemed a very natural and great fit. Unfortunately, Google seemed more convinced - for reasons that were outside the scope of this project - that this name related mostly with indian porn. desim - seemed fine initially, until we discovered another simulation engine https://github.com/aybabtme/desim with the same name. kalasim honors its origin by being somewhat phonetically similar to salabim while stressing Kotlin with the k , and the simulation scope with the sim instead of the bim . In case you also wonder why salabim was named salabim , see here . Can we use it with from Java? Kotlin-2-Java interop is a core design goal of Kotlin. Thus, kalasim should work without any issues from java. However, we have not tried yet, so in case you struggle please file a ticket. Why can we use resource.request(1)? Admittedly, the provided resource request syntax request(resource) feels a bit dated. It's designed in that way because we would need multiple receiver support for extensions functions to provide a more object-oriented API. However, extensions with multiple receivers are not (yet) supported by Kotlin.","title":"FAQ"},{"location":"faq/#faq","text":"","title":"F.A.Q."},{"location":"faq/#why-rebuilding-salabim","text":"Great question! Initial development was driven by curiosity about the salabim internals. Also, it lacked (arguably) a modern touch which made some of our use cases more tricky to implement. kalasim implements the great majority of salabim features as documented under https://www.salabim.org/manual/ including Components ComponentGenerator Queue Distributions (via apache-commons-math) Monitor Resource State Not planned Animation - which we believe should live in a separate codebase. Visualization in kalasim is detailed out in the visualization chapter .","title":"Why rebuilding salabim?"},{"location":"faq/#what-tf-is-the-meaning-of-kalasim","text":"We went through multiple iterations to come up with this great name: desimuk - {d}iscrete {e}vent {simu}lation with {k}otlin seemed a very natural and great fit. Unfortunately, Google seemed more convinced - for reasons that were outside the scope of this project - that this name related mostly with indian porn. desim - seemed fine initially, until we discovered another simulation engine https://github.com/aybabtme/desim with the same name. kalasim honors its origin by being somewhat phonetically similar to salabim while stressing Kotlin with the k , and the simulation scope with the sim instead of the bim . In case you also wonder why salabim was named salabim , see here .","title":"What (TF) is the meaning of kalasim?"},{"location":"faq/#can-we-use-it-with-from-java","text":"Kotlin-2-Java interop is a core design goal of Kotlin. Thus, kalasim should work without any issues from java. However, we have not tried yet, so in case you struggle please file a ticket.","title":"Can we use it with from Java?"},{"location":"faq/#why-can-we-use-resourcerequest1","text":"Admittedly, the provided resource request syntax request(resource) feels a bit dated. It's designed in that way because we would need multiple receiver support for extensions functions to provide a more object-oriented API. However, extensions with multiple receivers are not (yet) supported by Kotlin.","title":"Why can we use resource.request(1)?"},{"location":"monitors/","text":"Monitors Monitors are a way to collect data from the simulation. They are automatically collected for resources , components , states and queues . On top of that the user can define her own monitors. Monitors can be used to get statistics and as a feed for graphical tools. There are two types of monitors: Level monitors are useful to collect data about a variable that keeps its value over a certain length of time, such as the length of a queue orcthe colour of a traffic light. Non level monitors are useful to collect data about that occur just once. Examples, are the length of stay in a queue, or the number of processing steps of a part. For both types, the time is always collected, along with the value. Monitors support a wide range of statistical properties via m.statistics() including mean median percentiles min and max standard deviation histograms For all these statistics, it is possible to exclude zero entries, e.g. m.statistics(statistics=true) returns the mean, excluding zero entries. Monitors can be disabled with disable() by setting the boolean flag ``. m . diable () // disable monitoring m . reset () // reenable statistics monitoring m . reset ( initalValue ) // reenable level monitoring Continuation of a temporarily disabled monitor is currently not supported. Non level monitors Non level monitors collects values which do not reflect a level, e.g. the processing time of a part. There are 2 implementations to support categorical and numerical attributes org.kalasim.NumericStatisticMonitor org.kalasim.FrequencyMonitor Besides, it is possible to get all collected values as list with m.statistics().values . Calling m.reset() will clear all tallied values. Level monitor Level monitors tally levels along with the current (simulation) time. E.g. the number of parts a machine is working on. There are 2 implementations to support categorical and numerical attributes org.kalasim.FrequencyLevelMonitor org.kalasim.NumericLevelMonitor Level monitors allow to query the value at a specific time val nlm = NumericLevelMonitor () // ... collecting some data ... nlm [ 4 ] // will print the value at time 4 In addition to standard statistics, level monitor support the following statistics duration For all statistics, it is possible to exclude zero entries, e.g. m.statistics(excludeZeros=true).mean returns the mean, excluding zero entries. {todo} implement off tallying Calling m.reset() will clear all tallied values and timestamps. The statistics of a level monitor can be printed with m.printStatistics() . Histograms The statistics of a monitor can be printed with printStatistics() . E.g: waitingLine.lengthOfStayMonitor.printStatistics() : { \"all\" : { \"entries\" : 5 , \"ninty_pct_quantile\" : 4.142020545932034 , \"median\" : 1.836 , \"mean\" : 1.211 , \"nintyfive_pct_quantile\" : 4.142020545932034 , \"standard_deviation\" : 1.836 }, \"excl_zeros\" : { \"entries\" : 2 , \"ninty_pct_quantile\" : 4.142020545932034 , \"median\" : 1.576 , \"mean\" : 3.027 , \"nintyfive_pct_quantile\" : 4.142020545932034 , \"standard_deviation\" : 1.576 } } And, a histogram can be printed with printHistogram() . E.g. waitingLine.lengthOfStayMonitor.printHistogram() : Histogram of: 'Available quantity of fuel_pump' bin | entries | pct | [146.45, 151.81] | 1 | .33 | ************* [151.81, 157.16] | 0 | .00 | [157.16, 162.52] | 0 | .00 | [162.52, 167.87] | 0 | .00 | [167.87, 173.23] | 1 | .33 | ************* [173.23, 178.58] | 0 | .00 | [178.58, 183.94] | 0 | .00 | [183.94, 189.29] | 0 | .00 | [189.29, 194.65] | 0 | .00 | [194.65, 200.00] | 1 | .33 | ************* If neither binCount , nor lowerBound nor upperBound are specified, the histogram will be autoscaled. Histograms can be printed with their values, instead of bins. This is particularly useful for non numeric tallied values, such as names:: val m = FrequencyMonitor < Car > () m . addValue ( AUDI ) m . addValue ( AUDI ) m . addValue ( VW ) repeat ( 4 ) { m . addValue ( PORSCHE )} m . printHistogram () The output of this: Summary of: 'FrequencyMonitor.2' # Records: 7 # Levels: 3 Histogram of: 'FrequencyMonitor.2' bin | entries | pct | AUDI | 2 | .29 | *********** VW | 1 | .14 | ****** PORSCHE | 4 | .57 | *********************** It is also possible to specify the values to be shown: m.printHistogram(values = listOf(AUDI, TOYOTA)) This results in a further aggregated histogram view where non-selected values are agregated and listes values are forced in the display even if they were not observed. Summary of: 'FrequencyMonitor.1' # Records: 7 # Levels: 3 Histogram of: 'FrequencyMonitor.1' bin | entries | pct | AUDI | 2 | .29 | *********** TOYOTA | 0 | .00 | rest | 5 | .71 | ***************************** It is also possible to sort the histogram on the weight (or number of entries) of the value: m.printHistogram(sortByWeight = true) The output of this: Summary of: 'FrequencyMonitor.1' # Records: 7 # Levels: 3 Histogram of: 'FrequencyMonitor.1' bin | entries | pct | PORSCHE | 4 | .57 | *********************** AUDI | 2 | .29 | *********** VW | 1 | .14 | ****** For numeric monitors it is possible to show values instead of ranges as bins val nlm = NumericLevelMonitor () now += 2 nlm . addValue ( 2 ) now += 2 nlm . addValue ( 6 ) now += 4 nlm . printHistogram ( valueBins = false ) nlm . printHistogram ( valueBins = true ) which will result by default in Histogram of: 'NumericLevelMonitor.1' bin | entries | pct | [.00, .60] | 232 | .23 | ********* [.60, 1.20] | 0 | .00 | [1.20, 1.80] | 0 | .00 | [1.80, 2.40] | 233 | .23 | ********* [2.40, 3.00] | 0 | .00 | [3.00, 3.60] | 0 | .00 | [3.60, 4.20] | 0 | .00 | [4.20, 4.80] | 0 | .00 | [4.80, 5.40] | 0 | .00 | [5.40, 6.00] | 535 | .54 | ********************* However, when valueBins is enabled the histogram becomes Histogram of: 'NumericLevelMonitor.1' bin | entries | pct | 0.0 | 2 | .25 | ********** 2.0 | 2 | .25 | ********** 6.0 | 4 | .50 | ******************** Merging of Monitors Tt is possible to merge the resulting statistics of multiple monitors val flmA = FrequencyLevelMonitor ( 1 ) val flmB = FrequencyLevelMonitor ( 2 ) // ... run simulation val mergedStats : EnumeratedDistribution < Int > = listOf ( flmA , flmB ). mergeStats () See MergeMonitorTests for more examples regarding the other monitor types. Slicing of monitors Note : Slicing of monitors as in salabim is not yet supported. If needed please file a ticket . Use-cases for slicing are to get statistics on a monitor with respect to a given time period, most likely a subrun to get statistics on a monitor with respect to a recurring time period, like hour 0-1, hour 0-2, etc. Summarizing a monitor Monitor.statistics() returns a 'frozen' monitor that can be used to store the results not depending on the current environment. This is particularly useful for persisting monitor statistics for later analysis. Visualization It is possible to render monitors with the following extension functions NumericStatisticMonitor . display () NumericLevelMonitor . display () In particular multiple outputs are supported here by the underlying kravis visualization windows, which allows forward backward navigation (via the arrow buttons). See org.kalasim.examples.bank.resources.Bank3ClerksResources for an example where multiple visualizing are combined to inspect the internal state of the simulation. Note that, currently monitor visualization just works in retrospect, and it is not (yet) possible to view the progression while a simulation is still running.","title":"Monitors"},{"location":"monitors/#monitors","text":"Monitors are a way to collect data from the simulation. They are automatically collected for resources , components , states and queues . On top of that the user can define her own monitors. Monitors can be used to get statistics and as a feed for graphical tools. There are two types of monitors: Level monitors are useful to collect data about a variable that keeps its value over a certain length of time, such as the length of a queue orcthe colour of a traffic light. Non level monitors are useful to collect data about that occur just once. Examples, are the length of stay in a queue, or the number of processing steps of a part. For both types, the time is always collected, along with the value. Monitors support a wide range of statistical properties via m.statistics() including mean median percentiles min and max standard deviation histograms For all these statistics, it is possible to exclude zero entries, e.g. m.statistics(statistics=true) returns the mean, excluding zero entries. Monitors can be disabled with disable() by setting the boolean flag ``. m . diable () // disable monitoring m . reset () // reenable statistics monitoring m . reset ( initalValue ) // reenable level monitoring Continuation of a temporarily disabled monitor is currently not supported.","title":"Monitors"},{"location":"monitors/#non-level-monitors","text":"Non level monitors collects values which do not reflect a level, e.g. the processing time of a part. There are 2 implementations to support categorical and numerical attributes org.kalasim.NumericStatisticMonitor org.kalasim.FrequencyMonitor Besides, it is possible to get all collected values as list with m.statistics().values . Calling m.reset() will clear all tallied values.","title":"Non level monitors"},{"location":"monitors/#level-monitor","text":"Level monitors tally levels along with the current (simulation) time. E.g. the number of parts a machine is working on. There are 2 implementations to support categorical and numerical attributes org.kalasim.FrequencyLevelMonitor org.kalasim.NumericLevelMonitor Level monitors allow to query the value at a specific time val nlm = NumericLevelMonitor () // ... collecting some data ... nlm [ 4 ] // will print the value at time 4 In addition to standard statistics, level monitor support the following statistics duration For all statistics, it is possible to exclude zero entries, e.g. m.statistics(excludeZeros=true).mean returns the mean, excluding zero entries. {todo} implement off tallying Calling m.reset() will clear all tallied values and timestamps. The statistics of a level monitor can be printed with m.printStatistics() .","title":"Level monitor"},{"location":"monitors/#histograms","text":"The statistics of a monitor can be printed with printStatistics() . E.g: waitingLine.lengthOfStayMonitor.printStatistics() : { \"all\" : { \"entries\" : 5 , \"ninty_pct_quantile\" : 4.142020545932034 , \"median\" : 1.836 , \"mean\" : 1.211 , \"nintyfive_pct_quantile\" : 4.142020545932034 , \"standard_deviation\" : 1.836 }, \"excl_zeros\" : { \"entries\" : 2 , \"ninty_pct_quantile\" : 4.142020545932034 , \"median\" : 1.576 , \"mean\" : 3.027 , \"nintyfive_pct_quantile\" : 4.142020545932034 , \"standard_deviation\" : 1.576 } } And, a histogram can be printed with printHistogram() . E.g. waitingLine.lengthOfStayMonitor.printHistogram() : Histogram of: 'Available quantity of fuel_pump' bin | entries | pct | [146.45, 151.81] | 1 | .33 | ************* [151.81, 157.16] | 0 | .00 | [157.16, 162.52] | 0 | .00 | [162.52, 167.87] | 0 | .00 | [167.87, 173.23] | 1 | .33 | ************* [173.23, 178.58] | 0 | .00 | [178.58, 183.94] | 0 | .00 | [183.94, 189.29] | 0 | .00 | [189.29, 194.65] | 0 | .00 | [194.65, 200.00] | 1 | .33 | ************* If neither binCount , nor lowerBound nor upperBound are specified, the histogram will be autoscaled. Histograms can be printed with their values, instead of bins. This is particularly useful for non numeric tallied values, such as names:: val m = FrequencyMonitor < Car > () m . addValue ( AUDI ) m . addValue ( AUDI ) m . addValue ( VW ) repeat ( 4 ) { m . addValue ( PORSCHE )} m . printHistogram () The output of this: Summary of: 'FrequencyMonitor.2' # Records: 7 # Levels: 3 Histogram of: 'FrequencyMonitor.2' bin | entries | pct | AUDI | 2 | .29 | *********** VW | 1 | .14 | ****** PORSCHE | 4 | .57 | *********************** It is also possible to specify the values to be shown: m.printHistogram(values = listOf(AUDI, TOYOTA)) This results in a further aggregated histogram view where non-selected values are agregated and listes values are forced in the display even if they were not observed. Summary of: 'FrequencyMonitor.1' # Records: 7 # Levels: 3 Histogram of: 'FrequencyMonitor.1' bin | entries | pct | AUDI | 2 | .29 | *********** TOYOTA | 0 | .00 | rest | 5 | .71 | ***************************** It is also possible to sort the histogram on the weight (or number of entries) of the value: m.printHistogram(sortByWeight = true) The output of this: Summary of: 'FrequencyMonitor.1' # Records: 7 # Levels: 3 Histogram of: 'FrequencyMonitor.1' bin | entries | pct | PORSCHE | 4 | .57 | *********************** AUDI | 2 | .29 | *********** VW | 1 | .14 | ****** For numeric monitors it is possible to show values instead of ranges as bins val nlm = NumericLevelMonitor () now += 2 nlm . addValue ( 2 ) now += 2 nlm . addValue ( 6 ) now += 4 nlm . printHistogram ( valueBins = false ) nlm . printHistogram ( valueBins = true ) which will result by default in Histogram of: 'NumericLevelMonitor.1' bin | entries | pct | [.00, .60] | 232 | .23 | ********* [.60, 1.20] | 0 | .00 | [1.20, 1.80] | 0 | .00 | [1.80, 2.40] | 233 | .23 | ********* [2.40, 3.00] | 0 | .00 | [3.00, 3.60] | 0 | .00 | [3.60, 4.20] | 0 | .00 | [4.20, 4.80] | 0 | .00 | [4.80, 5.40] | 0 | .00 | [5.40, 6.00] | 535 | .54 | ********************* However, when valueBins is enabled the histogram becomes Histogram of: 'NumericLevelMonitor.1' bin | entries | pct | 0.0 | 2 | .25 | ********** 2.0 | 2 | .25 | ********** 6.0 | 4 | .50 | ********************","title":"Histograms"},{"location":"monitors/#merging-of-monitors","text":"Tt is possible to merge the resulting statistics of multiple monitors val flmA = FrequencyLevelMonitor ( 1 ) val flmB = FrequencyLevelMonitor ( 2 ) // ... run simulation val mergedStats : EnumeratedDistribution < Int > = listOf ( flmA , flmB ). mergeStats () See MergeMonitorTests for more examples regarding the other monitor types.","title":"Merging of Monitors"},{"location":"monitors/#slicing-of-monitors","text":"Note : Slicing of monitors as in salabim is not yet supported. If needed please file a ticket . Use-cases for slicing are to get statistics on a monitor with respect to a given time period, most likely a subrun to get statistics on a monitor with respect to a recurring time period, like hour 0-1, hour 0-2, etc.","title":"Slicing of monitors"},{"location":"monitors/#summarizing-a-monitor","text":"Monitor.statistics() returns a 'frozen' monitor that can be used to store the results not depending on the current environment. This is particularly useful for persisting monitor statistics for later analysis.","title":"Summarizing a monitor"},{"location":"monitors/#visualization","text":"It is possible to render monitors with the following extension functions NumericStatisticMonitor . display () NumericLevelMonitor . display () In particular multiple outputs are supported here by the underlying kravis visualization windows, which allows forward backward navigation (via the arrow buttons). See org.kalasim.examples.bank.resources.Bank3ClerksResources for an example where multiple visualizing are combined to inspect the internal state of the simulation. Note that, currently monitor visualization just works in retrospect, and it is not (yet) possible to view the progression while a simulation is still running.","title":"Visualization"},{"location":"resource/","text":"Resources Resources are a powerful way of process interaction. A resource has always a capacity (which can be zero and even negative). This capacity will be specified at time of creation, but can be changed later with r.capacity = newCapacity . Note that this may lead to requesting components to be honored if possible. There are two of types resources: Standard resources , where each claim is associated with a component (the claimer). It is not necessary that the claimed quantities are integer. Depletable resources , where only the claimed quantity is registered. This is most useful for dealing with levels, lengths, etc. Examples Bank Office with Resources Car Wash Traffic Gas Station Usage Resources are defined like: val clerks = Resource ( \"clerks\" , capacity = 3 ) val customer = Component ( \"clerks\" ) The customer can request a clerk in its process method : request ( clerks ) // request 1 from clerks request ( clerks withQuantity 2 ) // request 2s from clerks request has the effect that the component will check whether the requested quantity from a resource is available. It is possible to check for multiple availability of a certain quantity from several resources. It is also possible to request for more resources at once. In the following examples, we request 1 quantity from clerks AND 2 quantities from assistance . request ( clerks withQuantity 1 , assistance withQuantity 2 ) To request alternative resources, the user can define the parameter oneOf=true , which will would result in requesting 1 quantity from clerks OR 2 quantities from assistance . Resources have a queue requesters containing all components trying to claim from the resource. In addition, there is a queue claimers containing all components claiming from the resource (not for anonymous resources). It is possible to release a quantity from a resource with c.release() , e.g. customer . release () // releases all claimed quantity from r customer . release ( 2 ) // release quantity 2 from r Alternatively, it is possible to release from a resource directly, e.g. // releases the total quantity from all claiming components: r . release () // releases 10 from the resource; only valid for anonymous resources r . release ( 10 ) After a release, all requesting components will be checked whether their claim can be honored. Notes request is not allowed for data components or main. If to be used for the current component (which will be nearly always the case), use yield (request(...)) . If the same resource is specified more that once, the quantities are summed. The requested quantity may exceed the current capacity of a resource. The parameter failed will be reset by a calling request or wait . Monitors Resources have a number monitors: claimers queueLength lengthOfStay requesters queueLength lengthOfStay claimedQuantity availableQuantity capacity occupancy (= claimed quantity / capacity) By default, all monitors are enabled. With r.printStatistics() the key statistics of these all monitors are printed. E.g. { \"availableQuantity\" : { \"duration\" : 3000 , \"min\" : 0 , \"max\" : 3 , \"mean\" : 0.115 , \"standard_deviation\" : 0.332 }, \"claimedQuantity\" : { \"duration\" : 3000 , \"min\" : 0 , \"max\" : 3 , \"mean\" : 2.885 , \"standard_deviation\" : 0.332 }, \"occupancy\" : { \"duration\" : 3000 , \"min\" : 0 , \"max\" : 1 , \"mean\" : 0.962 , \"standard_deviation\" : 0.111 }, \"name\" : \"clerks\" , \"requesterStats\" : { \"queue_length\" : { \"all\" : { \"duration\" : 3000 , \"min\" : 0 , \"max\" : 3 , \"mean\" : 0.564 , \"standard_deviation\" : 0.727 }, \"excl_zeros\" : { \"duration\" : 1283.1906989415463 , \"min\" : 1 , \"max\" : 3 , \"mean\" : 1.319 , \"standard_deviation\" : 0.49 } }, \"name\" : \"requesters of clerks\" , \"length_of_stay\" : { \"all\" : { \"entries\" : 290 , \"ninty_pct_quantile\" : 15.336764014133065 , \"median\" : 6.97 , \"mean\" : 5.771 , \"nintyfive_pct_quantile\" : 17.9504616361896 , \"standard_deviation\" : 6.97 }, \"excl_zeros\" : { \"entries\" : 205 , \"ninty_pct_quantile\" : 17.074664209460025 , \"median\" : 7.014 , \"mean\" : 8.163 , \"nintyfive_pct_quantile\" : 19.28443602612993 , \"standard_deviation\" : 7.014 } }, \"type\" : \"QueueStatistics\" }, \"type\" : \"ResourceStatistics\" , \"timestamp\" : 3000 , \"claimerStats\" : { \"queue_length\" : { \"all\" : { \"duration\" : 3000 , \"min\" : 0 , \"max\" : 3 , \"mean\" : 2.885 , \"standard_deviation\" : 0.332 }, \"excl_zeros\" : { \"duration\" : 3000 , \"min\" : 1 , \"max\" : 3 , \"mean\" : 2.885 , \"standard_deviation\" : 0.332 } }, \"name\" : \"claimers of clerks\" , \"length_of_stay\" : { \"all\" : { \"entries\" : 287 , \"ninty_pct_quantile\" : 30 , \"median\" : 0 , \"mean\" : 30 , \"nintyfive_pct_quantile\" : 30 , \"standard_deviation\" : 0 }, \"excl_zeros\" : { \"entries\" : 287 , \"ninty_pct_quantile\" : 30 , \"median\" : 0 , \"mean\" : 30 , \"nintyfive_pct_quantile\" : 30 , \"standard_deviation\" : 0 } }, \"type\" : \"QueueStatistics\" }, \"capacity\" : { \"duration\" : 3000 , \"min\" : 3 , \"max\" : 3 , \"mean\" : 3 , \"standard_deviation\" : 0 } } With r.printInfo() a summary of the contents of the queues can be printed. E.g.: { \"claimedQuantity\" : 3 , \"requestingComponents\" : [ { \"component\" : \"Customer.292\" , \"quantity\" : 1 }, { \"component\" : \"Customer.291\" , \"quantity\" : 1 } ], \"creationTime\" : 0 , \"name\" : \"clerks\" , \"claimedBy\" : [ { \"first\" : \"Customer.288\" , \"second\" : null }, { \"first\" : \"Customer.289\" , \"second\" : null }, { \"first\" : \"Customer.290\" , \"second\" : null } ], \"capacity\" : 3 } Querying of the capacity, claimed quantity, available quantity and occupancy can be done with: r.capacity , r.claimedQuantity , r.availableQuantity and r.occupancy . All quantities are tracked by corresponding level monitors to provide statistics. If the capacity of a resource is constant, which is very common, the mean occupancy can be found with: r.occupancyMonitor.statistics().mean When the capacity changes over time, it is recommended to use: occupancy = r.claimedQuanityMonitor.statistics().mean / r.capacityMonitor.statistics().mean() to obtain the mean occupancy. Note that the occupancy is set to 0 if the capacity of the resource is <= 0. Resource Selection There is a special mechanism to select resources dynamically. With selectResource() a resource can be selected from a list of resources using a policy. There are several policies provided: SHORTEST_QUEUE : The resource with the shortest queue, i.e. the least busy resource is selected. ROUND_ROBIN : Resources will be selected in a cyclical order. FIRST_AVAILABLE : The first available resource is selected. RANDOM : A resource is randomly selected. The *_AVAILABLE policies check for resource availability (i.e. whether the current capacity is sufficient to honor the requested quantity (defaulting to 1 ). Resources that do not meet this requirement will not be considered for selection. When using these policies, an error will be raised if all resources are unavailable. Warning With selectResource , a resource will be only selected. It won't actually request it. Example ////ResourceSelection.kts import org.kalasim.* import org.kalasim.ResourceSelectionPolicy.* createSimulation ( false ) { val doctors = List ( 3 ) { Resource () } class Patient : Component () { override fun process () = sequence { val requiredQuantity = 3 val selected = selectResource ( doctors , quantity = requiredQuantity , policy = SHORTEST_QUEUE ) request ( selected withQuantity requiredQuantity ) { hold ( 10 ) } } } ComponentGenerator ( exponential ( 1 )){ Patient ()} run ( 100 ) } An alternative more direct approach to achieve round-robin resource selection (e.g. for nested calls) could also be implemented ( example ) with an iterator. Depletable Resources For depletable (which are also referred to as anonymous ) resources, it may be not allowed to exceed the capacity and have a component wait for enough (claimed) capacity to be available. That may be accomplished by using a negative quantity in the Component.request() call. To create a depleteable resource we {done} val tank = DepletableResource ( capacity = 10 , initialLevel = 5 ) We can declare its maximum capacity and its initial fill level. The latter is optional and defaults to the capacity of the resource. Alternatively, it possible to use the Component.put() method, where quantities of anonymous resources are negated. For symmetry reasons, kalasim also offers the Component.get() method, which is behaves exactly like Component.request() . The model below illustrates the use of get and put . See the Gas Station simulation for a living example. Pre-emptive Resources It is possible to specify that a resource is to be preemptive, by adding preemptive = true when the resource is created. If a component requests from a preemptive resource, it may bump component(s) that are claiming from the resource, provided these have a lower priority = higher value). If component is bumped, it releases the resource and is then activated, thus essentially stopping the current action (usually hold or passivate ). Therefore, a component claiming from a preemptive resource should check whether the component is bumped or still claiming at any point where they can be bumped. This can be done with the method Component.isClaiming(resource) which is true if the component is claiming from the resource, or the opposite (Component.isBumped) which is true is the component is not claiming from the resource. Examples Machine Shop","title":"Resources"},{"location":"resource/#resources","text":"Resources are a powerful way of process interaction. A resource has always a capacity (which can be zero and even negative). This capacity will be specified at time of creation, but can be changed later with r.capacity = newCapacity . Note that this may lead to requesting components to be honored if possible. There are two of types resources: Standard resources , where each claim is associated with a component (the claimer). It is not necessary that the claimed quantities are integer. Depletable resources , where only the claimed quantity is registered. This is most useful for dealing with levels, lengths, etc.","title":"Resources"},{"location":"resource/#examples","text":"Bank Office with Resources Car Wash Traffic Gas Station","title":"Examples"},{"location":"resource/#usage","text":"Resources are defined like: val clerks = Resource ( \"clerks\" , capacity = 3 ) val customer = Component ( \"clerks\" ) The customer can request a clerk in its process method : request ( clerks ) // request 1 from clerks request ( clerks withQuantity 2 ) // request 2s from clerks request has the effect that the component will check whether the requested quantity from a resource is available. It is possible to check for multiple availability of a certain quantity from several resources. It is also possible to request for more resources at once. In the following examples, we request 1 quantity from clerks AND 2 quantities from assistance . request ( clerks withQuantity 1 , assistance withQuantity 2 ) To request alternative resources, the user can define the parameter oneOf=true , which will would result in requesting 1 quantity from clerks OR 2 quantities from assistance . Resources have a queue requesters containing all components trying to claim from the resource. In addition, there is a queue claimers containing all components claiming from the resource (not for anonymous resources). It is possible to release a quantity from a resource with c.release() , e.g. customer . release () // releases all claimed quantity from r customer . release ( 2 ) // release quantity 2 from r Alternatively, it is possible to release from a resource directly, e.g. // releases the total quantity from all claiming components: r . release () // releases 10 from the resource; only valid for anonymous resources r . release ( 10 ) After a release, all requesting components will be checked whether their claim can be honored. Notes request is not allowed for data components or main. If to be used for the current component (which will be nearly always the case), use yield (request(...)) . If the same resource is specified more that once, the quantities are summed. The requested quantity may exceed the current capacity of a resource. The parameter failed will be reset by a calling request or wait .","title":"Usage"},{"location":"resource/#monitors","text":"Resources have a number monitors: claimers queueLength lengthOfStay requesters queueLength lengthOfStay claimedQuantity availableQuantity capacity occupancy (= claimed quantity / capacity) By default, all monitors are enabled. With r.printStatistics() the key statistics of these all monitors are printed. E.g. { \"availableQuantity\" : { \"duration\" : 3000 , \"min\" : 0 , \"max\" : 3 , \"mean\" : 0.115 , \"standard_deviation\" : 0.332 }, \"claimedQuantity\" : { \"duration\" : 3000 , \"min\" : 0 , \"max\" : 3 , \"mean\" : 2.885 , \"standard_deviation\" : 0.332 }, \"occupancy\" : { \"duration\" : 3000 , \"min\" : 0 , \"max\" : 1 , \"mean\" : 0.962 , \"standard_deviation\" : 0.111 }, \"name\" : \"clerks\" , \"requesterStats\" : { \"queue_length\" : { \"all\" : { \"duration\" : 3000 , \"min\" : 0 , \"max\" : 3 , \"mean\" : 0.564 , \"standard_deviation\" : 0.727 }, \"excl_zeros\" : { \"duration\" : 1283.1906989415463 , \"min\" : 1 , \"max\" : 3 , \"mean\" : 1.319 , \"standard_deviation\" : 0.49 } }, \"name\" : \"requesters of clerks\" , \"length_of_stay\" : { \"all\" : { \"entries\" : 290 , \"ninty_pct_quantile\" : 15.336764014133065 , \"median\" : 6.97 , \"mean\" : 5.771 , \"nintyfive_pct_quantile\" : 17.9504616361896 , \"standard_deviation\" : 6.97 }, \"excl_zeros\" : { \"entries\" : 205 , \"ninty_pct_quantile\" : 17.074664209460025 , \"median\" : 7.014 , \"mean\" : 8.163 , \"nintyfive_pct_quantile\" : 19.28443602612993 , \"standard_deviation\" : 7.014 } }, \"type\" : \"QueueStatistics\" }, \"type\" : \"ResourceStatistics\" , \"timestamp\" : 3000 , \"claimerStats\" : { \"queue_length\" : { \"all\" : { \"duration\" : 3000 , \"min\" : 0 , \"max\" : 3 , \"mean\" : 2.885 , \"standard_deviation\" : 0.332 }, \"excl_zeros\" : { \"duration\" : 3000 , \"min\" : 1 , \"max\" : 3 , \"mean\" : 2.885 , \"standard_deviation\" : 0.332 } }, \"name\" : \"claimers of clerks\" , \"length_of_stay\" : { \"all\" : { \"entries\" : 287 , \"ninty_pct_quantile\" : 30 , \"median\" : 0 , \"mean\" : 30 , \"nintyfive_pct_quantile\" : 30 , \"standard_deviation\" : 0 }, \"excl_zeros\" : { \"entries\" : 287 , \"ninty_pct_quantile\" : 30 , \"median\" : 0 , \"mean\" : 30 , \"nintyfive_pct_quantile\" : 30 , \"standard_deviation\" : 0 } }, \"type\" : \"QueueStatistics\" }, \"capacity\" : { \"duration\" : 3000 , \"min\" : 3 , \"max\" : 3 , \"mean\" : 3 , \"standard_deviation\" : 0 } } With r.printInfo() a summary of the contents of the queues can be printed. E.g.: { \"claimedQuantity\" : 3 , \"requestingComponents\" : [ { \"component\" : \"Customer.292\" , \"quantity\" : 1 }, { \"component\" : \"Customer.291\" , \"quantity\" : 1 } ], \"creationTime\" : 0 , \"name\" : \"clerks\" , \"claimedBy\" : [ { \"first\" : \"Customer.288\" , \"second\" : null }, { \"first\" : \"Customer.289\" , \"second\" : null }, { \"first\" : \"Customer.290\" , \"second\" : null } ], \"capacity\" : 3 } Querying of the capacity, claimed quantity, available quantity and occupancy can be done with: r.capacity , r.claimedQuantity , r.availableQuantity and r.occupancy . All quantities are tracked by corresponding level monitors to provide statistics. If the capacity of a resource is constant, which is very common, the mean occupancy can be found with: r.occupancyMonitor.statistics().mean When the capacity changes over time, it is recommended to use: occupancy = r.claimedQuanityMonitor.statistics().mean / r.capacityMonitor.statistics().mean() to obtain the mean occupancy. Note that the occupancy is set to 0 if the capacity of the resource is <= 0.","title":"Monitors"},{"location":"resource/#resource-selection","text":"There is a special mechanism to select resources dynamically. With selectResource() a resource can be selected from a list of resources using a policy. There are several policies provided: SHORTEST_QUEUE : The resource with the shortest queue, i.e. the least busy resource is selected. ROUND_ROBIN : Resources will be selected in a cyclical order. FIRST_AVAILABLE : The first available resource is selected. RANDOM : A resource is randomly selected. The *_AVAILABLE policies check for resource availability (i.e. whether the current capacity is sufficient to honor the requested quantity (defaulting to 1 ). Resources that do not meet this requirement will not be considered for selection. When using these policies, an error will be raised if all resources are unavailable. Warning With selectResource , a resource will be only selected. It won't actually request it. Example ////ResourceSelection.kts import org.kalasim.* import org.kalasim.ResourceSelectionPolicy.* createSimulation ( false ) { val doctors = List ( 3 ) { Resource () } class Patient : Component () { override fun process () = sequence { val requiredQuantity = 3 val selected = selectResource ( doctors , quantity = requiredQuantity , policy = SHORTEST_QUEUE ) request ( selected withQuantity requiredQuantity ) { hold ( 10 ) } } } ComponentGenerator ( exponential ( 1 )){ Patient ()} run ( 100 ) } An alternative more direct approach to achieve round-robin resource selection (e.g. for nested calls) could also be implemented ( example ) with an iterator.","title":"Resource Selection"},{"location":"resource/#depletable-resources","text":"For depletable (which are also referred to as anonymous ) resources, it may be not allowed to exceed the capacity and have a component wait for enough (claimed) capacity to be available. That may be accomplished by using a negative quantity in the Component.request() call. To create a depleteable resource we {done} val tank = DepletableResource ( capacity = 10 , initialLevel = 5 ) We can declare its maximum capacity and its initial fill level. The latter is optional and defaults to the capacity of the resource. Alternatively, it possible to use the Component.put() method, where quantities of anonymous resources are negated. For symmetry reasons, kalasim also offers the Component.get() method, which is behaves exactly like Component.request() . The model below illustrates the use of get and put . See the Gas Station simulation for a living example.","title":"Depletable Resources"},{"location":"resource/#pre-emptive-resources","text":"It is possible to specify that a resource is to be preemptive, by adding preemptive = true when the resource is created. If a component requests from a preemptive resource, it may bump component(s) that are claiming from the resource, provided these have a lower priority = higher value). If component is bumped, it releases the resource and is then activated, thus essentially stopping the current action (usually hold or passivate ). Therefore, a component claiming from a preemptive resource should check whether the component is bumped or still claiming at any point where they can be bumped. This can be done with the method Component.isClaiming(resource) which is true if the component is claiming from the resource, or the opposite (Component.isBumped) which is true is the component is not claiming from the resource. Examples Machine Shop","title":"Pre-emptive Resources"},{"location":"setup/","text":"Installation kalasim requires Java11 or higher. Gradle To get started simply add it as a dependency via Jcenter: repositories { jcenter() } dependencies { implementation \"com.github.holgerbrandl:kalasim:0.6.7\" } Jitpack Integration You can also use JitPack with Maven or Gradle to build the latest snapshot as a dependency in your project. repositories { maven { url 'https://jitpack.io' } } dependencies { implementation 'com.github.holgerbrandl:kalasim:-SNAPSHOT' } How to build it from sources? To build and install it into your local maven cache, simply clone the repo and run ./gradlew install","title":"Setup"},{"location":"setup/#installation","text":"kalasim requires Java11 or higher.","title":"Installation"},{"location":"setup/#gradle","text":"To get started simply add it as a dependency via Jcenter: repositories { jcenter() } dependencies { implementation \"com.github.holgerbrandl:kalasim:0.6.7\" }","title":"Gradle"},{"location":"setup/#jitpack-integration","text":"You can also use JitPack with Maven or Gradle to build the latest snapshot as a dependency in your project. repositories { maven { url 'https://jitpack.io' } } dependencies { implementation 'com.github.holgerbrandl:kalasim:-SNAPSHOT' }","title":"Jitpack Integration"},{"location":"setup/#how-to-build-it-from-sources","text":"To build and install it into your local maven cache, simply clone the repo and run ./gradlew install","title":"How to build it from sources?"},{"location":"state/","text":"State States together provide a powerful way of process interaction. A state will have a value at any given time. In its simplest form a component can wait() for a specific value of a state. Once that value is reached, the component will be resumed. Examples Traffic Bank Office with 1 clerk Bank Office With Balking And Reneging Usage New States are defined as val doorOpen = State(false) . The initial value is false , meaning the door is closed. Now we can say : doorOpen . value = true to open the door. If we want a person to wait for an open door, we could say : wait ( doorOpen , true ) The person's process definition will be suspended until the door is open. We can obtain the current value (e.g. for logging) with: print ( \"\"\"door is ${ if ( doorOpen . value ) \" open \" else \" closed \" } \"\"\" ) The value of a state is automatically monitored in the State<T>.valueMonitor level monitor. All components waiting for a state are tracked in a (internal) queue, that can be obtained with doorOpen.waiters . If we just want at most one person to enter, we can use trigger() (which is a simple convenience wrapper around wait) with doorOpen.trigger(true, max=1) . The following will happen: Temporarily change the state to the provided value, Reschedule max components (or less if there are fewer/no waiters ) for immediate process continuation, and finally restore the previous state value Type Support States support generics, so we could equally well use any other type to model the value. For example, a traffic light could be modelled with a String state: // initially the traffic light is red val light = State(\"red\") ... // toggle its value to green light.value = \"green\" Or define a int/float state : val level = State(0.0) level.value += 10 Since State<T> is a generic type, the compiler will reject invalid level associations such as level.value = \"red\" This won't compile because the type of level is Double . Metrics States have a number of metrics endpoints: valueMonitor tracks state changes over time queueLength tracks the queue length level across time lengthOfStay tracks the length of stay in the queue over time Process interaction with wait() A component can wait() for a state to get a certain value. In its most simple form this is done with wait ( doorOpen , true ) Once the doorOpen state is true , the component will be scheduled for process continuation. As with request it is possible to set a timeout with failAt or failDelay : wait ( dooropen , true , failDelay = 10.0 ) if ( failed ) print ( \"impatient ...\" ) In this example, the process will wait at max 10 ticks. If the state predicate was not met until then, the failed flag will be set and be consumed by the user. There are two ways to test for a value Value testing Predicate testing Value Testing It is possible to test for a certain value: wait ( light , \"green\" ) Or more states at once: wait ( light turns \"green\" , light turns \"yellow\" ) where the wait is honored as soon is light is green OR yellow . It is also possible to wait for all conditions to be satisfied, by adding all=true : wait ( light turns \"green\" , engineRunning turns true , all = true ) Here, the wait is honored as soon as light is green AND the engine is running. Predicate testing This is a more complicated but also more versatile way of specifying the honor-condition. In that case, a predicate function (T) -> Boolean must be provided required to specify the condition. Example 1 wait ( StateRequest ( State ( \"foo\" )) { listOf ( \"bar\" , \"test\" ). contains ( it ) }) The wait is honored if the String State becomes either bar or test . Example 2 wait ( StateRequest ( State ( 3.0 )) { it * 3 < 42 }) In this last example the wait is honored as soon as the value fulfils it*3 < 42 .","title":"States"},{"location":"state/#state","text":"States together provide a powerful way of process interaction. A state will have a value at any given time. In its simplest form a component can wait() for a specific value of a state. Once that value is reached, the component will be resumed.","title":"State"},{"location":"state/#examples","text":"Traffic Bank Office with 1 clerk Bank Office With Balking And Reneging","title":"Examples"},{"location":"state/#usage","text":"New States are defined as val doorOpen = State(false) . The initial value is false , meaning the door is closed. Now we can say : doorOpen . value = true to open the door. If we want a person to wait for an open door, we could say : wait ( doorOpen , true ) The person's process definition will be suspended until the door is open. We can obtain the current value (e.g. for logging) with: print ( \"\"\"door is ${ if ( doorOpen . value ) \" open \" else \" closed \" } \"\"\" ) The value of a state is automatically monitored in the State<T>.valueMonitor level monitor. All components waiting for a state are tracked in a (internal) queue, that can be obtained with doorOpen.waiters . If we just want at most one person to enter, we can use trigger() (which is a simple convenience wrapper around wait) with doorOpen.trigger(true, max=1) . The following will happen: Temporarily change the state to the provided value, Reschedule max components (or less if there are fewer/no waiters ) for immediate process continuation, and finally restore the previous state value","title":"Usage"},{"location":"state/#type-support","text":"States support generics, so we could equally well use any other type to model the value. For example, a traffic light could be modelled with a String state: // initially the traffic light is red val light = State(\"red\") ... // toggle its value to green light.value = \"green\" Or define a int/float state : val level = State(0.0) level.value += 10 Since State<T> is a generic type, the compiler will reject invalid level associations such as level.value = \"red\" This won't compile because the type of level is Double .","title":"Type Support"},{"location":"state/#metrics","text":"States have a number of metrics endpoints: valueMonitor tracks state changes over time queueLength tracks the queue length level across time lengthOfStay tracks the length of stay in the queue over time","title":"Metrics"},{"location":"state/#process-interaction-with-wait","text":"A component can wait() for a state to get a certain value. In its most simple form this is done with wait ( doorOpen , true ) Once the doorOpen state is true , the component will be scheduled for process continuation. As with request it is possible to set a timeout with failAt or failDelay : wait ( dooropen , true , failDelay = 10.0 ) if ( failed ) print ( \"impatient ...\" ) In this example, the process will wait at max 10 ticks. If the state predicate was not met until then, the failed flag will be set and be consumed by the user. There are two ways to test for a value Value testing Predicate testing","title":"Process interaction with wait()"},{"location":"state/#value-testing","text":"It is possible to test for a certain value: wait ( light , \"green\" ) Or more states at once: wait ( light turns \"green\" , light turns \"yellow\" ) where the wait is honored as soon is light is green OR yellow . It is also possible to wait for all conditions to be satisfied, by adding all=true : wait ( light turns \"green\" , engineRunning turns true , all = true ) Here, the wait is honored as soon as light is green AND the engine is running.","title":"Value Testing"},{"location":"state/#predicate-testing","text":"This is a more complicated but also more versatile way of specifying the honor-condition. In that case, a predicate function (T) -> Boolean must be provided required to specify the condition.","title":"Predicate testing"},{"location":"state/#example-1","text":"wait ( StateRequest ( State ( \"foo\" )) { listOf ( \"bar\" , \"test\" ). contains ( it ) }) The wait is honored if the String State becomes either bar or test .","title":"Example 1"},{"location":"state/#example-2","text":"wait ( StateRequest ( State ( 3.0 )) { it * 3 < 42 }) In this last example the wait is honored as soon as the value fulfils it*3 < 42 .","title":"Example 2"},{"location":"theory/","text":"Simulation Theory As defined by Shannon (1975), a simulation is the process of designing a model of a real system and conducting experiments with this model for the purpose either of understanding the behavior of the system or of evaluating various strategies (within the limits imposed by a criterion or a set of criteria) for the operation of the system. What is discrete event simulation? A discrete event simulation (DES) is a tool that allows studying the dynamic behavior of stochastic, dynamic and discretely evolving systems such as Factories Ports & Airports Traffic Supply chains & Logistics Controlling In fact, every process that is founded on discrete state changes is suitable to be simulated with a discrete event simulation such as kalasim . As described by Ucar, 2019 , the discrete nature of a given system arises as soon as its behavior can be described in terms of events, which is the most fundamental concept in DES. An event is an instantaneous occurrence that may change the state of the system, while, between events, all the state variables remain. There are several main DES paradigms. In activity-oriented DES the simulation clock advances in fixed time increments and all simulation entities are scanned and possibly reevaluated. Clearly, simulation performance degrades quickly with smaller increments and increasingly complex models. In event-oriented DES is built around a list of scheduled events ordered by future execution time. During simulation, the these events are processed seqeuentially to update the state of the model. Finally, process-oriented DES refines the event-oriented approach by defining a vocabulary of interactions to describe the interplay between simulation entities. This vocabulary is used by the modeler to define the component life-cycle processes of each simulation entity. Applications of discrete event simulation Depending on the system in question, DES and kalasim in particular can provide insights into the process efficiency, risks or effectiveness. In addition, it allows assessing alternative what-if scenarios. Very often planning is all about estimating the effect of changes to a system. such as more/fewer driver, more/fewer machines, more/less repair cycles, more/fewer cargo trolleys. Typical applications of discrete event simulations are Production planning (such as bottleneck analysis) Dimensioning (How many drivers are needed? Number of servers?) Process automation & visualization Digital twin development Project management For in-depth primers about simulation see here or Ucar, 2019 . Other Simulation Tools There are too many to be listed. In generally there are graphical tools and APIs . Graphical tools, such as AnyLogic excel by providing a flat learning curve, great visuals but often lack interfaces for extensibility or automation. APIs are usually much more flexible but often lack an intuitive approach to actually build simulations. Out of the great number of APIs, we pinpoint just those projects/products which served as source of inspiration when developing kalasim .","title":"Theory"},{"location":"theory/#simulation-theory","text":"As defined by Shannon (1975), a simulation is the process of designing a model of a real system and conducting experiments with this model for the purpose either of understanding the behavior of the system or of evaluating various strategies (within the limits imposed by a criterion or a set of criteria) for the operation of the system.","title":"Simulation Theory"},{"location":"theory/#what-is-discrete-event-simulation","text":"A discrete event simulation (DES) is a tool that allows studying the dynamic behavior of stochastic, dynamic and discretely evolving systems such as Factories Ports & Airports Traffic Supply chains & Logistics Controlling In fact, every process that is founded on discrete state changes is suitable to be simulated with a discrete event simulation such as kalasim . As described by Ucar, 2019 , the discrete nature of a given system arises as soon as its behavior can be described in terms of events, which is the most fundamental concept in DES. An event is an instantaneous occurrence that may change the state of the system, while, between events, all the state variables remain. There are several main DES paradigms. In activity-oriented DES the simulation clock advances in fixed time increments and all simulation entities are scanned and possibly reevaluated. Clearly, simulation performance degrades quickly with smaller increments and increasingly complex models. In event-oriented DES is built around a list of scheduled events ordered by future execution time. During simulation, the these events are processed seqeuentially to update the state of the model. Finally, process-oriented DES refines the event-oriented approach by defining a vocabulary of interactions to describe the interplay between simulation entities. This vocabulary is used by the modeler to define the component life-cycle processes of each simulation entity.","title":"What is discrete event simulation?"},{"location":"theory/#applications-of-discrete-event-simulation","text":"Depending on the system in question, DES and kalasim in particular can provide insights into the process efficiency, risks or effectiveness. In addition, it allows assessing alternative what-if scenarios. Very often planning is all about estimating the effect of changes to a system. such as more/fewer driver, more/fewer machines, more/less repair cycles, more/fewer cargo trolleys. Typical applications of discrete event simulations are Production planning (such as bottleneck analysis) Dimensioning (How many drivers are needed? Number of servers?) Process automation & visualization Digital twin development Project management For in-depth primers about simulation see here or Ucar, 2019 .","title":"Applications of discrete event simulation"},{"location":"theory/#other-simulation-tools","text":"There are too many to be listed. In generally there are graphical tools and APIs . Graphical tools, such as AnyLogic excel by providing a flat learning curve, great visuals but often lack interfaces for extensibility or automation. APIs are usually much more flexible but often lack an intuitive approach to actually build simulations. Out of the great number of APIs, we pinpoint just those projects/products which served as source of inspiration when developing kalasim .","title":"Other Simulation Tools"},{"location":"visualization/","text":"Visualization There are two type of visualizations Statistical plots to inspect distributions, trends and outliers. That's what described in this chapter Process rendering to actually show simulation entities, their state or position changes on a 2D (or even 3D) grid as rendered movie. This may also involve interactive controls to adjust simulation parameters. Such functionality is planned but not yet implemented in kalasim Examples * Movie Theater Statistical plots Currently the following extensions for distribution analysis are supported FrequencyLevelMonitor<T>.display() provides a segment chart of the level FrequencyTable<T>.display() provides a barchart of the frequencies of the different values NumericStatisticMonitor.display() provides histogram of the underlying distribution NumericLevelMonitor.display() provides a line chart with time on the x and the value on y For monitors , see corresponding section Framework Support By default, kalasim supports 2 pluggable visualization backends. Currently kravis and lets-plot are supported. Since we may not be able to support all visualizations in both frontends, the user can simply toggle the frontend by package import: // simply toggle backend by package import import org.kalasim.plot.letsplot.display // or //import org.kalasim.plot.kravis.display MM1Queue (). apply { run ( 100 ) server . claimedMonitor . display () } Kravis kalasim integrates nicely with kravis to visualize monitor data. For examples see src/test/kotlin/org/kalasim/analytics/KravisVis.kt . Note To visualize data with kravis, R must be installed on the system. See here ) for details. LetsPlot lets-plot is another very modern visualization library that renders within the JVM and thus does not have any external dependencies. Similar to kravis it mimics the API of ggplot2 . Currently, lets-plot works best in jupyter notebooks. We provide a basic JVM wrapper . For a more elaborate JVM solution please vote for lets-plot-kotlin/51 .","title":"Visualization"},{"location":"visualization/#visualization","text":"There are two type of visualizations Statistical plots to inspect distributions, trends and outliers. That's what described in this chapter Process rendering to actually show simulation entities, their state or position changes on a 2D (or even 3D) grid as rendered movie. This may also involve interactive controls to adjust simulation parameters. Such functionality is planned but not yet implemented in kalasim Examples * Movie Theater","title":"Visualization"},{"location":"visualization/#statistical-plots","text":"Currently the following extensions for distribution analysis are supported FrequencyLevelMonitor<T>.display() provides a segment chart of the level FrequencyTable<T>.display() provides a barchart of the frequencies of the different values NumericStatisticMonitor.display() provides histogram of the underlying distribution NumericLevelMonitor.display() provides a line chart with time on the x and the value on y For monitors , see corresponding section","title":"Statistical plots"},{"location":"visualization/#framework-support","text":"By default, kalasim supports 2 pluggable visualization backends. Currently kravis and lets-plot are supported. Since we may not be able to support all visualizations in both frontends, the user can simply toggle the frontend by package import: // simply toggle backend by package import import org.kalasim.plot.letsplot.display // or //import org.kalasim.plot.kravis.display MM1Queue (). apply { run ( 100 ) server . claimedMonitor . display () }","title":"Framework Support"},{"location":"visualization/#kravis","text":"kalasim integrates nicely with kravis to visualize monitor data. For examples see src/test/kotlin/org/kalasim/analytics/KravisVis.kt . Note To visualize data with kravis, R must be installed on the system. See here ) for details.","title":"Kravis"},{"location":"visualization/#letsplot","text":"lets-plot is another very modern visualization library that renders within the JVM and thus does not have any external dependencies. Similar to kravis it mimics the API of ggplot2 . Currently, lets-plot works best in jupyter notebooks. We provide a basic JVM wrapper . For a more elaborate JVM solution please vote for lets-plot-kotlin/51 .","title":"LetsPlot"},{"location":"examples/atm_queue/","text":"Simple Queue Model Let's explore the expressiveness of kalasim s process description using a traditional queuing example, the M/M/1 . This Kendall's notation describes a single server - here a ATM - with exponentially distributed arrivals, exponential service time and an infinte queue. The basic parameters of the system are \u03bb - people arrival rate at the ATM \u00b5 - money withdrawal rate If \u03bb/\u00b5 > 1, the queue is referred to as unstable since there are more arrivals than the ATM can handle. The queue will grow indefinitely. ////Atm.kt import org.apache.commons.math3.distribution.ExponentialDistribution import org.kalasim.* import org.kalasim.plot.kravis.display //https://youtrack.jetbrains.com/issue/KT-44062 fun main () { createSimulation ( false ) { val lambda = 1.5 val mu = 1.0 val rho = lambda / mu println ( \"rho is ${ rho } . With rho>1 the system would be unstable, \" + \"because there are more arrivals then the atm can serve.\" ) val atm = Resource ( \"atm\" , 1 ) class Customer : Component () { val ed = ExponentialDistribution ( rg , mu ) override fun process () = sequence { request ( atm ) hold ( ed . sample ()) release ( atm ) } } ComponentGenerator ( iat = exponential ( lambda )) { Customer () } run ( 2000 ) atm . occupancyMonitor . display () atm . requesters . queueLengthMonitor . display () atm . requesters . lengthOfStayMonitor . display () println ( atm . requesters . lengthOfStayMonitor . statistics ()) } } The ATM example is inspired from the simmer paper Ucar et al. 2019 . Simple What-If To ////ClassicWhatIfAtm.kt import krangl.* import org.apache.commons.math3.distribution.ExponentialDistribution import org.kalasim.Component import org.kalasim.ComponentGenerator import org.kalasim.Resource import org.kalasim.createSimulation import org.kalasim.misc.cartesianProduct import org.koin.core.component.get suspend fun main () { fun buildAtmSimulation ( mu : Double , lambda : Double ) = createSimulation { val atm = Resource ( \"atm\" , 1 ) _koin . declare ( atm ) class Customer : Component () { val ed = ExponentialDistribution ( rg , mu ) override fun process () = sequence { request ( atm ) hold ( ed . sample ()) release ( atm ) } } ComponentGenerator ( iat = ExponentialDistribution ( rg , lambda )) { Customer () } } // build parameter grid val lambdas = ( 1. . 20 ). map { 0.25 }. cumSum () val mus = ( 1. . 20 ). map { 0.25 }. cumSum () val meanAtmQueueLength = cartesianProduct ( lambdas , mus ). map { ( lambda , mu ) -> ( lambda to mu ) to lazy { buildAtmSimulation ( lambda , mu ) } }. toMap (). mapValues { ( _ , env ) -> env . value . run ( 100 ) env . value . get < Resource > (). statistics . requesters . lengthStats . mean } println ( meanAtmQueueLength . toList (). take ( 5 )) // or do the same more elegantly using krangl val df = dataFrameOf ( cartesianProduct ( lambdas , mus ) . map { mapOf ( \"lambda\" to it . first , \"mu\" to it . second ) } . asIterable ()) . groupByExpr { rowNumber } . addColumn ( \"mean_queue_length\" ) { // parameterize simulation val env = buildAtmSimulation ( it [ \"lambda\" ] . toDoubles (). first () !! , it [ \"mu\" ] . toDoubles (). first () !! ) env . run ( 100 ) env . get < Resource > (). statistics . requesters . lengthStats . mean } df . head (). print () } Parallel What-If ////ParallelWhatIfAtm.kt import kotlinx.coroutines.async import kotlinx.coroutines.awaitAll import kotlinx.coroutines.coroutineScope import krangl.cumSum import org.apache.commons.math3.distribution.ExponentialDistribution import org.kalasim.Component import org.kalasim.ComponentGenerator import org.kalasim.Resource import org.kalasim.createSimulation import org.kalasim.misc.cartesianProduct import org.koin.core.Koin import org.koin.core.component.get // Objective: Instantiate and run a simulation multiple times in parallel suspend fun main () { fun buildAtmSimulation ( mu : Double , lambda : Double ) = createSimulation ( useCustomKoin = true ) { val atm = Resource ( \"atm\" , 1 , koin = getKoin ()) _koin . declare ( atm ) class Customer ( koin : Koin ) : Component ( koin = koin ) { val ed = ExponentialDistribution ( rg , mu ) override fun process () = sequence { request ( atm ) hold ( ed . sample ()) release ( atm ) } } ComponentGenerator ( iat = ExponentialDistribution ( rg , lambda ), koin = getKoin ()) { Customer ( getKoin ()) } } // build parameter grid val lambdas = ( 1. . 20 ). map { 0.25 }. cumSum () val mus = ( 1. . 20 ). map { 0.25 }. cumSum () // with parallel map val meanAtmQueueLengthParallel = cartesianProduct ( lambdas , mus ). map { ( lambda , mu ) -> ( lambda to mu ) to lazy { buildAtmSimulation ( lambda , mu ) } }. toList (). map { ( params , env ) -> env . value . run ( 100 ) params to env . value . get < Resource > (). statistics . requesters . lengthStats . mean } println ( meanAtmQueueLengthParallel . take ( 5 )) } // https://stackoverflow.com/questions/34697828/parallel-operations-on-kotlin-collections suspend fun < A , B > Iterable < A > . pmap ( f : suspend ( A ) -> B ): List < B > = coroutineScope { map { async { f ( it ) } }. awaitAll () }","title":"ATM Queue"},{"location":"examples/atm_queue/#simple-queue-model","text":"Let's explore the expressiveness of kalasim s process description using a traditional queuing example, the M/M/1 . This Kendall's notation describes a single server - here a ATM - with exponentially distributed arrivals, exponential service time and an infinte queue. The basic parameters of the system are \u03bb - people arrival rate at the ATM \u00b5 - money withdrawal rate If \u03bb/\u00b5 > 1, the queue is referred to as unstable since there are more arrivals than the ATM can handle. The queue will grow indefinitely. ////Atm.kt import org.apache.commons.math3.distribution.ExponentialDistribution import org.kalasim.* import org.kalasim.plot.kravis.display //https://youtrack.jetbrains.com/issue/KT-44062 fun main () { createSimulation ( false ) { val lambda = 1.5 val mu = 1.0 val rho = lambda / mu println ( \"rho is ${ rho } . With rho>1 the system would be unstable, \" + \"because there are more arrivals then the atm can serve.\" ) val atm = Resource ( \"atm\" , 1 ) class Customer : Component () { val ed = ExponentialDistribution ( rg , mu ) override fun process () = sequence { request ( atm ) hold ( ed . sample ()) release ( atm ) } } ComponentGenerator ( iat = exponential ( lambda )) { Customer () } run ( 2000 ) atm . occupancyMonitor . display () atm . requesters . queueLengthMonitor . display () atm . requesters . lengthOfStayMonitor . display () println ( atm . requesters . lengthOfStayMonitor . statistics ()) } } The ATM example is inspired from the simmer paper Ucar et al. 2019 .","title":"Simple Queue Model"},{"location":"examples/atm_queue/#simple-what-if","text":"To ////ClassicWhatIfAtm.kt import krangl.* import org.apache.commons.math3.distribution.ExponentialDistribution import org.kalasim.Component import org.kalasim.ComponentGenerator import org.kalasim.Resource import org.kalasim.createSimulation import org.kalasim.misc.cartesianProduct import org.koin.core.component.get suspend fun main () { fun buildAtmSimulation ( mu : Double , lambda : Double ) = createSimulation { val atm = Resource ( \"atm\" , 1 ) _koin . declare ( atm ) class Customer : Component () { val ed = ExponentialDistribution ( rg , mu ) override fun process () = sequence { request ( atm ) hold ( ed . sample ()) release ( atm ) } } ComponentGenerator ( iat = ExponentialDistribution ( rg , lambda )) { Customer () } } // build parameter grid val lambdas = ( 1. . 20 ). map { 0.25 }. cumSum () val mus = ( 1. . 20 ). map { 0.25 }. cumSum () val meanAtmQueueLength = cartesianProduct ( lambdas , mus ). map { ( lambda , mu ) -> ( lambda to mu ) to lazy { buildAtmSimulation ( lambda , mu ) } }. toMap (). mapValues { ( _ , env ) -> env . value . run ( 100 ) env . value . get < Resource > (). statistics . requesters . lengthStats . mean } println ( meanAtmQueueLength . toList (). take ( 5 )) // or do the same more elegantly using krangl val df = dataFrameOf ( cartesianProduct ( lambdas , mus ) . map { mapOf ( \"lambda\" to it . first , \"mu\" to it . second ) } . asIterable ()) . groupByExpr { rowNumber } . addColumn ( \"mean_queue_length\" ) { // parameterize simulation val env = buildAtmSimulation ( it [ \"lambda\" ] . toDoubles (). first () !! , it [ \"mu\" ] . toDoubles (). first () !! ) env . run ( 100 ) env . get < Resource > (). statistics . requesters . lengthStats . mean } df . head (). print () }","title":"Simple What-If"},{"location":"examples/atm_queue/#parallel-what-if","text":"////ParallelWhatIfAtm.kt import kotlinx.coroutines.async import kotlinx.coroutines.awaitAll import kotlinx.coroutines.coroutineScope import krangl.cumSum import org.apache.commons.math3.distribution.ExponentialDistribution import org.kalasim.Component import org.kalasim.ComponentGenerator import org.kalasim.Resource import org.kalasim.createSimulation import org.kalasim.misc.cartesianProduct import org.koin.core.Koin import org.koin.core.component.get // Objective: Instantiate and run a simulation multiple times in parallel suspend fun main () { fun buildAtmSimulation ( mu : Double , lambda : Double ) = createSimulation ( useCustomKoin = true ) { val atm = Resource ( \"atm\" , 1 , koin = getKoin ()) _koin . declare ( atm ) class Customer ( koin : Koin ) : Component ( koin = koin ) { val ed = ExponentialDistribution ( rg , mu ) override fun process () = sequence { request ( atm ) hold ( ed . sample ()) release ( atm ) } } ComponentGenerator ( iat = ExponentialDistribution ( rg , lambda ), koin = getKoin ()) { Customer ( getKoin ()) } } // build parameter grid val lambdas = ( 1. . 20 ). map { 0.25 }. cumSum () val mus = ( 1. . 20 ). map { 0.25 }. cumSum () // with parallel map val meanAtmQueueLengthParallel = cartesianProduct ( lambdas , mus ). map { ( lambda , mu ) -> ( lambda to mu ) to lazy { buildAtmSimulation ( lambda , mu ) } }. toList (). map { ( params , env ) -> env . value . run ( 100 ) params to env . value . get < Resource > (). statistics . requesters . lengthStats . mean } println ( meanAtmQueueLengthParallel . take ( 5 )) } // https://stackoverflow.com/questions/34697828/parallel-operations-on-kotlin-collections suspend fun < A , B > Iterable < A > . pmap ( f : suspend ( A ) -> B ): List < B > = coroutineScope { map { async { f ( it ) } }. awaitAll () }","title":"Parallel What-If"},{"location":"examples/bank_office/","text":"Queue problems are common-place application of discrete event simulation . Often there are multiple solutions for a model. Here we model similar problems - a customer queue - differently using resources, states and queues in various configurations and interaction patterns. Simple Bank Office (1 clerk) Lets start with a bank office where customers are arriving in a bank, where there is one clerk. This clerk handles the customers in a first in first out (FIFO) order. We see the following processes: The customer generator that creates the customers, with an inter-arrival time of uniform(5,15) The customers The clerk, which serves the customers in a constant time of 30 (overloaded and non steady state system) We need a queue for the customers to wait for service. The model code is: ////Bank1clerk.kt package org.kalasim.examples.bank.oneclerk import org.kalasim.* import org.kalasim.plot.kravis.canDisplay import org.kalasim.plot.kravis.display import org.koin.core.component.get import org.koin.core.component.inject class Customer ( val waitingLine : ComponentQueue < Customer > , val clerk : Clerk ) : Component () { override fun process () = sequence { waitingLine . add ( this @Customer ) if ( clerk . isPassive ) clerk . activate () passivate () } } class Clerk : Component () { val waitingLine : ComponentQueue < Customer > by inject () override fun process () = sequence { while ( true ) { while ( waitingLine . isEmpty ()) passivate () val customer = waitingLine . poll () hold ( 10.0 ) // bearbeitungszeit customer . activate () } } } class CustomerGenerator : Component () { // var numCreated = 0 override fun process () = sequence { // if(numCreated++ >5 ) return@sequence while ( true ) { Customer ( get (), get ()) hold ( uniform ( 5.0 , 15.1 ). sample ()) } } } fun main () { val deps = declareDependencies { add { Clerk () } add { ComponentQueue < Customer > ( \"waiting line\" ) } } val env = createSimulation ( true , dependencies = deps ) { CustomerGenerator () }. run ( 50.0 ) val waitingLine : ComponentQueue < Customer > = env . get () waitingLine . stats . print () if ( canDisplay ()) { waitingLine . queueLengthMonitor . display () waitingLine . lengthOfStayMonitor . display () } } Let's look at some details (marked in yellow for convenience). With: waitingLine . add ( this @Customer ) the customer places itself at the tail of the waiting line. Then, the customer checks whether the clerk is idle, and if so, activates him immediately.: if ( clerk . isPassive ) clerk . activate () Once the clerk is active (again), it gets the first customer out of the waitingline with: val customer = waitingLine . poll () and holds for 30 time units with: hold ( 10.0 ) After that hold the customer is activated and will terminate: customer . activate () In the main section of the program, we create the CustomerGenerator , the Clerk and a ComponentQueue called waitingline. Here the customer generator is implemented as a custom instance of Component for educational puroposes. Using the provided ComponentGenerator API would be more concise. hold ( uniform ( 5.0 , 15.0 ). sample ()) will do the statistical sampling and wait for that time till the next customer is created. Since logging is enabled when creating the simulation with createSimulation the following log trace is being produced time current component action info --------- ------------------------ -------------------------------------------- ---------------------------------- .00 main create .00 main .00 Clerk.1 create .00 Clerk.1 activate scheduled for .00 .00 CustomerGenerator.1 create .00 CustomerGenerator.1 activate scheduled for .00 .00 main run +50.00 scheduled for 50.00 .00 Clerk.1 .00 Clerk.1 passivate .00 CustomerGenerator.1 .00 Customer.1 create .00 Customer.1 activate scheduled for .00 .00 CustomerGenerator.1 hold +11.95 scheduled for 11.95 .00 Customer.1 .00 Customer.1 entering waiting line .00 Clerk.1 activate scheduled for .00 .00 Customer.1 passivate .00 Clerk.1 .00 Customer.1 leaving waiting line .00 Clerk.1 hold +10.00 scheduled for 10.00 10.00 Clerk.1 10.00 Customer.1 activate scheduled for 10.00 10.00 Clerk.1 passivate 10.00 Customer.1 10.00 Customer.1 ended 11.95 CustomerGenerator.1 11.95 Customer.2 create 11.95 Customer.2 activate scheduled for 11.95 11.95 CustomerGenerator.1 hold +7.73 scheduled for 19.68 11.95 Customer.2 11.95 Customer.2 entering waiting line 11.95 Clerk.1 activate scheduled for 11.95 11.95 Customer.2 passivate 11.95 Clerk.1 11.95 Customer.2 leaving waiting line 11.95 Clerk.1 hold +10.00 scheduled for 21.95 19.68 CustomerGenerator.1 19.68 Customer.3 create 19.68 Customer.3 activate scheduled for 19.68 19.68 CustomerGenerator.1 hold +10.32 scheduled for 30.00 19.68 Customer.3 19.68 Customer.3 entering waiting line 19.68 Customer.3 passivate 21.95 Clerk.1 21.95 Customer.2 activate scheduled for 21.95 21.95 Customer.3 leaving waiting line 21.95 Clerk.1 hold +10.00 scheduled for 31.95 21.95 Customer.2 21.95 Customer.2 ended 30.00 CustomerGenerator.1 30.00 Customer.4 create 30.00 Customer.4 activate scheduled for 30.00 30.00 CustomerGenerator.1 hold +10.63 scheduled for 40.63 30.00 Customer.4 30.00 Customer.4 entering waiting line 30.00 Customer.4 passivate 31.95 Clerk.1 31.95 Customer.3 activate scheduled for 31.95 31.95 Customer.4 leaving waiting line 31.95 Clerk.1 hold +10.00 scheduled for 41.95 31.95 Customer.3 31.95 Customer.3 ended 40.63 CustomerGenerator.1 40.63 Customer.5 create 40.63 Customer.5 activate scheduled for 40.63 40.63 CustomerGenerator.1 hold +5.31 scheduled for 45.95 40.63 Customer.5 40.63 Customer.5 entering waiting line 40.63 Customer.5 passivate 41.95 Clerk.1 41.95 Customer.4 activate scheduled for 41.95 41.95 Customer.5 leaving waiting line 41.95 Clerk.1 hold +10.00 scheduled for 51.95 41.95 Customer.4 41.95 Customer.4 ended 45.95 CustomerGenerator.1 45.95 Customer.6 create 45.95 Customer.6 activate scheduled for 45.95 45.95 CustomerGenerator.1 hold +12.68 scheduled for 58.63 45.95 Customer.6 45.95 Customer.6 entering waiting line 45.95 Customer.6 passivate 50.00 main After the simulation is finished, the statistics of the queue are presented with: waitingLine . stats . print () The statistics output looks like { \"queue_length\" : { \"all\" : { \"duration\" : 50 , \"min\" : 0 , \"max\" : 1 , \"mean\" : 0.15 , \"standard_deviation\" : 0.361 }, \"excl_zeros\" : { \"duration\" : 7.500540828621098 , \"min\" : 1 , \"max\" : 1 , \"mean\" : 1 , \"standard_deviation\" : 0 } }, \"name\" : \"waiting line\" , \"length_of_stay\" : { \"all\" : { \"entries\" : 5 , \"ninty_pct_quantile\" : 3.736 , \"median\" : 1.684 , \"mean\" : 1.334 , \"nintyfive_pct_quantile\" : 3.736 , \"standard_deviation\" : 1.684 }, \"excl_zeros\" : { \"entries\" : 3 , \"ninty_pct_quantile\" : 3.736 , \"median\" : 1.645 , \"mean\" : 2.223 , \"nintyfive_pct_quantile\" : 3.736 , \"standard_deviation\" : 1.645 } }, \"type\" : \"QueueStatistics\" , \"timestamp\" : 50 } Bank Office with 3 Clerks Now, let's add more clerks: add { ( 1. . 3 ). map { Clerk () } } And, every time a customer enters the waiting line, we need to make sure at least one passive clerk (if any) is activated: for ( c in clerks ) { if ( c . isPassive ) { c . activate () break // activate at max one clerk } } The complete source of a three clerk post office: ////Bank3Clerks.kt package org.kalasim.examples.bank.threeclerks import org.kalasim.* import org.kalasim.plot.kravis.canDisplay import org.kalasim.plot.kravis.display import org.koin.core.component.get import org.koin.core.component.inject class CustomerGenerator : Component () { override fun process () = sequence { while ( true ) { Customer ( get ()) hold ( uniform ( 5.0 , 15.0 ). sample ()) } } } class Customer ( val waitingLine : ComponentQueue < Customer > ) : Component () { private val clerks : List < Clerk > by inject () override fun process () = sequence { waitingLine . add ( this @Customer ) for ( c in clerks ) { if ( c . isPassive ) { c . activate () break // activate at max one clerk } } passivate () } } class Clerk : Component () { private val waitingLine : ComponentQueue < Customer > by inject () override fun process () = sequence { while ( true ) { if ( waitingLine . isEmpty ()) passivate () val customer = waitingLine . poll () hold ( 30.0 ) // bearbeitungszeit customer . activate () // signal the customer that's all's done } } } fun main () { val env = configureEnvironment { // register components needed for dependency injection add { ComponentQueue < Customer > ( \"waitingline\" ) } add { State ( false , \"worktodo\" ) } add { CustomerGenerator () } add { ( 1. . 3 ). map { Clerk () } } } env . apply { run ( 50000.0 ) val waitingLine : ComponentQueue < Customer > = get () if ( canDisplay ()) { // waitingLine.lengthOfStayMonitor.printHistogram() // waitingLine.queueLengthMonitor.printHistogram() waitingLine . queueLengthMonitor . display () waitingLine . lengthOfStayMonitor . display () } // waitingLine.stats.toJson().toString(2).printThis() waitingLine . printInfo () } } Bank Office with Resources kalasim contains another useful concept for modelling: Resources . Resources have a limited capacity and can be claimed by components and released later. In the model of the bank with the same functionality as the above example, the clerks are defined as a resource with capacity 3. The model code is: ////Bank3ClerksResources.kt package org.kalasim.examples.bank.resources import org.kalasim.* import org.kalasim.plot.kravis.canDisplay import org.kalasim.plot.kravis.display import org.koin.core.component.get class Customer ( private val clerks : Resource ) : Component () { override fun process () = sequence { request ( clerks ) hold ( 30 ) release ( clerks ) // not really required } } fun main () { val env = configureEnvironment { add { Resource ( \"clerks\" , capacity = 3 ) } }. apply { ComponentGenerator ( iat = uniform ( 5.0 , 15.0 )) { Customer ( get ()) } }. run ( 3000 ) env . get < Resource > (). apply { printInfo () if ( canDisplay ()) { claimedMonitor . display () requesters . queueLengthMonitor . display () } printStatistics () } } Let's look at some details.: add { Resource ( \"clerks\" , capacity = 3 ) } This defines a resource with a capacity of 3 . Each customer tries to claim one unit (=clerk) from the resource with: request ( clerks ) B default 1 unit will be requested. If the resource is not available, the customer needs to wait for it to become available (in order of arrival). In contrast with the previous example, the customer now holds itself for 30 time units (clicks). After this time, the customer releases the resource with: release ( clerks ) The effect is that kalasim then tries to honor the next pending request, if any. In this case the release statement is not required, as resources that were claimed are automatically released when a process terminates).` The statistics are maintained in two system queues, called clerk.requesters and clerk.claimers . The output is very similar to the earlier example. The statistics are exactly the same. Bank Office with Balking and Reneging Now, we assume that clients are not going to the queue when there are more than 5 clients waiting (balking). On top of that, if a client is waiting longer than 50, he/she will leave as well (reneging). The model code is: ////Bank3ClerksReneging.kt package org.kalasim.examples.bank.reneging import org.kalasim.* import org.kalasim.misc.printThis import org.koin.core.component.get import org.koin.core.component.inject //**{todo}** use monitors here and maybe even inject them //to inject use data class Counter(var value: Int) var numBalked : Int = 0 var numReneged : Int = 0 class CustomerGenerator : Component () { override fun process () = sequence { while ( true ) { Customer ( get ()) hold ( uniform ( 5.0 , 15.0 ). sample ()) } } } class Customer ( val waitingLine : ComponentQueue < Customer > ) : Component () { private val clerks : List < Clerk > by inject () override fun process () = sequence { if ( waitingLine . size >= 5 ) { numBalked ++ log ( \"balked\" ) cancel () } waitingLine . add ( this @Customer ) for ( c in clerks ) { if ( c . isPassive ) { c . activate () break // activate only one clerk } } hold ( 50.0 ) // if not serviced within this time, renege if ( waitingLine . contains ( this @Customer )) { // this@Customer.leave(waitingLine) waitingLine . remove ( this @Customer ) numReneged ++ log ( \"reneged\" ) } else { // if customer no longer in waiting line, // serving has started meanwhile passivate () } } } class Clerk : Component () { private val waitingLine : ComponentQueue < Customer > by inject () override fun process () = sequence { while ( true ) { if ( waitingLine . isEmpty ()) passivate () val customer = waitingLine . poll () customer . activate () // get the customer out of it's hold(50) hold ( 30.0 ) // bearbeitungszeit customer . activate () // signal the customer that's all's done } } } fun main () { val env = configureEnvironment ( true ) { // register components needed for dependency injection add { ComponentQueue < Customer > ( \"waitingline\" ) } add { ( 0. . 2 ). map { Clerk () } } } env . apply { // register other components to be present when starting the simulation CustomerGenerator () val waitingLine : ComponentQueue < Customer > = get () waitingLine . lengthOfStayMonitor . disable () run ( 1500.0 ) waitingLine . lengthOfStayMonitor . enable () run ( 500.0 ) // with console waitingLine . lengthOfStayMonitor . printHistogram () waitingLine . queueLengthMonitor . printHistogram () // with kravis // waitingLine.queueLengthMonitor.display() // waitingLine.lengthOfStayMonitor.display() waitingLine . stats . toJson (). toString ( 2 ). printThis () println ( \"number reneged: $ numReneged \" ) println ( \"number balked: $ numBalked \" ) } } Let's look at some details. cancel () This makes the current component (a customer) a DATA component (and be subject to garbage collection), if the queue length is 5 or more. The reneging is implemented after a hold of 50 . If a clerk can service a customer, it will take the customer out of the waitingline and will activate it at that moment. The customer just has to check whether he/she is still in the waiting line. If so, he/she has not been serviced in time and thus will renege. hold ( 50.0 ) if ( waitingLine . contains ( this @Customer )) { waitingLine . leave ( this @Customer ) numReneged ++ printTrace ( \"reneged\" ) } else { passivate () } All the clerk has to do when starting servicing a client is to get the next customer in line out of the queue (as before) and activate this customer (at time now). The effect is that the hold of the customer will end. hold ( 30.0 ) customer . activate () // signal the customer that's all's done Bank Office with Balking and Reneging (resources) Now we show how balking and reneging can be implemented with resources. The model code is: ////Bank3ClerksRenegingResources.kt package org.kalasim.examples.bank.reneging_resources import org.kalasim.* import org.koin.core.component.get //var numBalked = LevelMonitoredInt(0) var numBalked = 0 var numReneged = 0 class Customer ( val clerks : Resource ) : Component () { override fun process () = sequence { if ( clerks . requesters . size >= 5 ) { numBalked ++ log ( \"balked\" ) cancel () } request ( clerks , failDelay = 50 ) if ( failed ) { numReneged ++ log ( \"reneged\" ) } else { hold ( 30 ) release ( clerks ) } } } fun main () { declareDependencies { add { Resource ( \"clerks\" , capacity = 3 ) } }. createSimulation { // register other components to be present when starting the simulation ComponentGenerator ( iat = uniform ( 5.0 , 15.0 )) { Customer ( get ()) } run ( 50000.0 ) val clerks = get < Resource > () // with console clerks . requesters . queueLengthMonitor . printHistogram () clerks . requesters . lengthOfStayMonitor . printHistogram () // with kravis // clerks.requesters.queueLengthMonitor.display() // clerks.requesters.lengthOfStayMonitor.display() println ( \"number reneged: $ numReneged \" ) println ( \"number balked: $ numBalked \" ) } } As you can see, the balking part is exactly the same as in the example without resources. For the renenging, all we have to do is add a failDelay : request ( clerks , failDelay = 50. asDist ()) If the request is not honored within 50 time units (ticks), the process continues after that request statement. We check whether the request has failed with the built-in Component property: iff ( failed ) numReneged ++ This example shows clearly the advantage of the resource solution over the passivate / activate method, in former example. Bank Office with States Another useful concept for modelling are states . In this case, we define a state called worktodo . The model code is: ////Bank3ClerksState.kt package org.kalasim.examples.bank.state import org.apache.commons.math3.distribution.UniformRealDistribution import org.kalasim.* import org.koin.core.component.get import org.koin.core.component.inject class CustomerGenerator : Component () { override fun process () = sequence { while ( true ) { Customer ( get (), get ()) hold ( UniformRealDistribution ( env . rg , 5.0 , 15.0 ). sample ()) } } } class Customer ( val workTodo : State < Boolean > , val waitingLine : ComponentQueue < Customer > ) : Component () { override fun process () = sequence { waitingLine . add ( this @Customer ) workTodo . trigger ( true , max = 1 ) passivate () } } class Clerk : Component () { val waitingLine : ComponentQueue < Customer > by inject () val workTodo : State < Boolean > by inject () override fun process () = sequence { while ( true ) { if ( waitingLine . isEmpty ()) wait ( workTodo , true ) val customer = waitingLine . poll () hold ( 32.0 ) // bearbeitungszeit customer . activate () } } } fun main () { val env = declareDependencies { // register components needed for dependency injection add { ComponentQueue < Customer > ( \"waitingline\" ) } add { State ( false , \"worktodo\" ) } }. createSimulation ( true ) { // register other components to be present // when starting the simulation repeat ( 3 ) { Clerk () } CustomerGenerator () }. run ( 500.0 ) env . get < ComponentQueue < Customer >> (). printStats () env . get < State < Boolean >> (). printInfo () // val waitingLine: ComponentQueue<Customer> = env.get() // waitingLine.stats.print() // waitingLine.queueLengthMonitor.display() } Let's look at some details. add { State ( false , \"worktodo\" ) } This defines a state with an initial value false and registers it as a dependency. In the code of the customer, the customer tries to trigger one clerk with: workTodo . trigger ( true , max = 1 ) The effect is that if there are clerks waiting for worktodo, the first clerk's wait is honored and that clerk continues its process after: wait ( workTodo , true ) Note that the clerk is only going to wait for worktodo after completion of a job if there are no customers waiting. Bank Office with Standby The kalasim package contains yet another powerful process mechanism, called standby . When a component is in STANDBY mode, it will become current after each event. Normally, the standby will be used in a while loop where at every event one or more conditions are checked. The model with standby is: ////Bank3ClerksStandby.kt import org.kalasim.* import org.kalasim.plot.kravis.display import org.koin.core.component.get import org.koin.core.component.inject class Customer ( val waitingLine : ComponentQueue < Customer > ) : Component () { override fun process () = sequence { waitingLine . add ( this @Customer ) passivate () } } class Clerk : Component () { val waitingLine : ComponentQueue < Customer > by inject () override fun process () = sequence { while ( true ) { while ( waitingLine . isEmpty ()) standby () val customer = waitingLine . poll () hold ( 32.0 ) // bearbeitungszeit customer . activate () } } } fun main () { val env = declareDependencies { add { ComponentQueue < Customer > ( \"waitingline\" ) } }. createSimulation ( true ) { repeat ( 3 ) { Clerk () } ComponentGenerator ( uniform ( 5 , 15 )) { Customer ( get ()) } } env . run ( 500.0 ) env . get < ComponentQueue < Customer >> (). apply { printInfo () printStats () lengthOfStayMonitor . display () } } In this case, the condition is checked frequently with: while ( waitingLine . isEmpty ()) standby () The rest of the code is very similar to the version with states. Warning It is very important to realize that this mechanism can have significant impact on the performance, as after EACH event, the component becomes current and has to be checked. In general, it is recommended to try and use state s or a more straightforward passivate / activate construction.","title":"Bank Office"},{"location":"examples/bank_office/#simple-bank-office-1-clerk","text":"Lets start with a bank office where customers are arriving in a bank, where there is one clerk. This clerk handles the customers in a first in first out (FIFO) order. We see the following processes: The customer generator that creates the customers, with an inter-arrival time of uniform(5,15) The customers The clerk, which serves the customers in a constant time of 30 (overloaded and non steady state system) We need a queue for the customers to wait for service. The model code is: ////Bank1clerk.kt package org.kalasim.examples.bank.oneclerk import org.kalasim.* import org.kalasim.plot.kravis.canDisplay import org.kalasim.plot.kravis.display import org.koin.core.component.get import org.koin.core.component.inject class Customer ( val waitingLine : ComponentQueue < Customer > , val clerk : Clerk ) : Component () { override fun process () = sequence { waitingLine . add ( this @Customer ) if ( clerk . isPassive ) clerk . activate () passivate () } } class Clerk : Component () { val waitingLine : ComponentQueue < Customer > by inject () override fun process () = sequence { while ( true ) { while ( waitingLine . isEmpty ()) passivate () val customer = waitingLine . poll () hold ( 10.0 ) // bearbeitungszeit customer . activate () } } } class CustomerGenerator : Component () { // var numCreated = 0 override fun process () = sequence { // if(numCreated++ >5 ) return@sequence while ( true ) { Customer ( get (), get ()) hold ( uniform ( 5.0 , 15.1 ). sample ()) } } } fun main () { val deps = declareDependencies { add { Clerk () } add { ComponentQueue < Customer > ( \"waiting line\" ) } } val env = createSimulation ( true , dependencies = deps ) { CustomerGenerator () }. run ( 50.0 ) val waitingLine : ComponentQueue < Customer > = env . get () waitingLine . stats . print () if ( canDisplay ()) { waitingLine . queueLengthMonitor . display () waitingLine . lengthOfStayMonitor . display () } } Let's look at some details (marked in yellow for convenience). With: waitingLine . add ( this @Customer ) the customer places itself at the tail of the waiting line. Then, the customer checks whether the clerk is idle, and if so, activates him immediately.: if ( clerk . isPassive ) clerk . activate () Once the clerk is active (again), it gets the first customer out of the waitingline with: val customer = waitingLine . poll () and holds for 30 time units with: hold ( 10.0 ) After that hold the customer is activated and will terminate: customer . activate () In the main section of the program, we create the CustomerGenerator , the Clerk and a ComponentQueue called waitingline. Here the customer generator is implemented as a custom instance of Component for educational puroposes. Using the provided ComponentGenerator API would be more concise. hold ( uniform ( 5.0 , 15.0 ). sample ()) will do the statistical sampling and wait for that time till the next customer is created. Since logging is enabled when creating the simulation with createSimulation the following log trace is being produced time current component action info --------- ------------------------ -------------------------------------------- ---------------------------------- .00 main create .00 main .00 Clerk.1 create .00 Clerk.1 activate scheduled for .00 .00 CustomerGenerator.1 create .00 CustomerGenerator.1 activate scheduled for .00 .00 main run +50.00 scheduled for 50.00 .00 Clerk.1 .00 Clerk.1 passivate .00 CustomerGenerator.1 .00 Customer.1 create .00 Customer.1 activate scheduled for .00 .00 CustomerGenerator.1 hold +11.95 scheduled for 11.95 .00 Customer.1 .00 Customer.1 entering waiting line .00 Clerk.1 activate scheduled for .00 .00 Customer.1 passivate .00 Clerk.1 .00 Customer.1 leaving waiting line .00 Clerk.1 hold +10.00 scheduled for 10.00 10.00 Clerk.1 10.00 Customer.1 activate scheduled for 10.00 10.00 Clerk.1 passivate 10.00 Customer.1 10.00 Customer.1 ended 11.95 CustomerGenerator.1 11.95 Customer.2 create 11.95 Customer.2 activate scheduled for 11.95 11.95 CustomerGenerator.1 hold +7.73 scheduled for 19.68 11.95 Customer.2 11.95 Customer.2 entering waiting line 11.95 Clerk.1 activate scheduled for 11.95 11.95 Customer.2 passivate 11.95 Clerk.1 11.95 Customer.2 leaving waiting line 11.95 Clerk.1 hold +10.00 scheduled for 21.95 19.68 CustomerGenerator.1 19.68 Customer.3 create 19.68 Customer.3 activate scheduled for 19.68 19.68 CustomerGenerator.1 hold +10.32 scheduled for 30.00 19.68 Customer.3 19.68 Customer.3 entering waiting line 19.68 Customer.3 passivate 21.95 Clerk.1 21.95 Customer.2 activate scheduled for 21.95 21.95 Customer.3 leaving waiting line 21.95 Clerk.1 hold +10.00 scheduled for 31.95 21.95 Customer.2 21.95 Customer.2 ended 30.00 CustomerGenerator.1 30.00 Customer.4 create 30.00 Customer.4 activate scheduled for 30.00 30.00 CustomerGenerator.1 hold +10.63 scheduled for 40.63 30.00 Customer.4 30.00 Customer.4 entering waiting line 30.00 Customer.4 passivate 31.95 Clerk.1 31.95 Customer.3 activate scheduled for 31.95 31.95 Customer.4 leaving waiting line 31.95 Clerk.1 hold +10.00 scheduled for 41.95 31.95 Customer.3 31.95 Customer.3 ended 40.63 CustomerGenerator.1 40.63 Customer.5 create 40.63 Customer.5 activate scheduled for 40.63 40.63 CustomerGenerator.1 hold +5.31 scheduled for 45.95 40.63 Customer.5 40.63 Customer.5 entering waiting line 40.63 Customer.5 passivate 41.95 Clerk.1 41.95 Customer.4 activate scheduled for 41.95 41.95 Customer.5 leaving waiting line 41.95 Clerk.1 hold +10.00 scheduled for 51.95 41.95 Customer.4 41.95 Customer.4 ended 45.95 CustomerGenerator.1 45.95 Customer.6 create 45.95 Customer.6 activate scheduled for 45.95 45.95 CustomerGenerator.1 hold +12.68 scheduled for 58.63 45.95 Customer.6 45.95 Customer.6 entering waiting line 45.95 Customer.6 passivate 50.00 main After the simulation is finished, the statistics of the queue are presented with: waitingLine . stats . print () The statistics output looks like { \"queue_length\" : { \"all\" : { \"duration\" : 50 , \"min\" : 0 , \"max\" : 1 , \"mean\" : 0.15 , \"standard_deviation\" : 0.361 }, \"excl_zeros\" : { \"duration\" : 7.500540828621098 , \"min\" : 1 , \"max\" : 1 , \"mean\" : 1 , \"standard_deviation\" : 0 } }, \"name\" : \"waiting line\" , \"length_of_stay\" : { \"all\" : { \"entries\" : 5 , \"ninty_pct_quantile\" : 3.736 , \"median\" : 1.684 , \"mean\" : 1.334 , \"nintyfive_pct_quantile\" : 3.736 , \"standard_deviation\" : 1.684 }, \"excl_zeros\" : { \"entries\" : 3 , \"ninty_pct_quantile\" : 3.736 , \"median\" : 1.645 , \"mean\" : 2.223 , \"nintyfive_pct_quantile\" : 3.736 , \"standard_deviation\" : 1.645 } }, \"type\" : \"QueueStatistics\" , \"timestamp\" : 50 }","title":"Simple Bank Office (1 clerk)"},{"location":"examples/bank_office/#bank-office-with-3-clerks","text":"Now, let's add more clerks: add { ( 1. . 3 ). map { Clerk () } } And, every time a customer enters the waiting line, we need to make sure at least one passive clerk (if any) is activated: for ( c in clerks ) { if ( c . isPassive ) { c . activate () break // activate at max one clerk } } The complete source of a three clerk post office: ////Bank3Clerks.kt package org.kalasim.examples.bank.threeclerks import org.kalasim.* import org.kalasim.plot.kravis.canDisplay import org.kalasim.plot.kravis.display import org.koin.core.component.get import org.koin.core.component.inject class CustomerGenerator : Component () { override fun process () = sequence { while ( true ) { Customer ( get ()) hold ( uniform ( 5.0 , 15.0 ). sample ()) } } } class Customer ( val waitingLine : ComponentQueue < Customer > ) : Component () { private val clerks : List < Clerk > by inject () override fun process () = sequence { waitingLine . add ( this @Customer ) for ( c in clerks ) { if ( c . isPassive ) { c . activate () break // activate at max one clerk } } passivate () } } class Clerk : Component () { private val waitingLine : ComponentQueue < Customer > by inject () override fun process () = sequence { while ( true ) { if ( waitingLine . isEmpty ()) passivate () val customer = waitingLine . poll () hold ( 30.0 ) // bearbeitungszeit customer . activate () // signal the customer that's all's done } } } fun main () { val env = configureEnvironment { // register components needed for dependency injection add { ComponentQueue < Customer > ( \"waitingline\" ) } add { State ( false , \"worktodo\" ) } add { CustomerGenerator () } add { ( 1. . 3 ). map { Clerk () } } } env . apply { run ( 50000.0 ) val waitingLine : ComponentQueue < Customer > = get () if ( canDisplay ()) { // waitingLine.lengthOfStayMonitor.printHistogram() // waitingLine.queueLengthMonitor.printHistogram() waitingLine . queueLengthMonitor . display () waitingLine . lengthOfStayMonitor . display () } // waitingLine.stats.toJson().toString(2).printThis() waitingLine . printInfo () } }","title":"Bank Office with 3 Clerks"},{"location":"examples/bank_office/#bank-office-with-resources","text":"kalasim contains another useful concept for modelling: Resources . Resources have a limited capacity and can be claimed by components and released later. In the model of the bank with the same functionality as the above example, the clerks are defined as a resource with capacity 3. The model code is: ////Bank3ClerksResources.kt package org.kalasim.examples.bank.resources import org.kalasim.* import org.kalasim.plot.kravis.canDisplay import org.kalasim.plot.kravis.display import org.koin.core.component.get class Customer ( private val clerks : Resource ) : Component () { override fun process () = sequence { request ( clerks ) hold ( 30 ) release ( clerks ) // not really required } } fun main () { val env = configureEnvironment { add { Resource ( \"clerks\" , capacity = 3 ) } }. apply { ComponentGenerator ( iat = uniform ( 5.0 , 15.0 )) { Customer ( get ()) } }. run ( 3000 ) env . get < Resource > (). apply { printInfo () if ( canDisplay ()) { claimedMonitor . display () requesters . queueLengthMonitor . display () } printStatistics () } } Let's look at some details.: add { Resource ( \"clerks\" , capacity = 3 ) } This defines a resource with a capacity of 3 . Each customer tries to claim one unit (=clerk) from the resource with: request ( clerks ) B default 1 unit will be requested. If the resource is not available, the customer needs to wait for it to become available (in order of arrival). In contrast with the previous example, the customer now holds itself for 30 time units (clicks). After this time, the customer releases the resource with: release ( clerks ) The effect is that kalasim then tries to honor the next pending request, if any. In this case the release statement is not required, as resources that were claimed are automatically released when a process terminates).` The statistics are maintained in two system queues, called clerk.requesters and clerk.claimers . The output is very similar to the earlier example. The statistics are exactly the same.","title":"Bank Office with Resources"},{"location":"examples/bank_office/#bank-office-with-balking-and-reneging","text":"Now, we assume that clients are not going to the queue when there are more than 5 clients waiting (balking). On top of that, if a client is waiting longer than 50, he/she will leave as well (reneging). The model code is: ////Bank3ClerksReneging.kt package org.kalasim.examples.bank.reneging import org.kalasim.* import org.kalasim.misc.printThis import org.koin.core.component.get import org.koin.core.component.inject //**{todo}** use monitors here and maybe even inject them //to inject use data class Counter(var value: Int) var numBalked : Int = 0 var numReneged : Int = 0 class CustomerGenerator : Component () { override fun process () = sequence { while ( true ) { Customer ( get ()) hold ( uniform ( 5.0 , 15.0 ). sample ()) } } } class Customer ( val waitingLine : ComponentQueue < Customer > ) : Component () { private val clerks : List < Clerk > by inject () override fun process () = sequence { if ( waitingLine . size >= 5 ) { numBalked ++ log ( \"balked\" ) cancel () } waitingLine . add ( this @Customer ) for ( c in clerks ) { if ( c . isPassive ) { c . activate () break // activate only one clerk } } hold ( 50.0 ) // if not serviced within this time, renege if ( waitingLine . contains ( this @Customer )) { // this@Customer.leave(waitingLine) waitingLine . remove ( this @Customer ) numReneged ++ log ( \"reneged\" ) } else { // if customer no longer in waiting line, // serving has started meanwhile passivate () } } } class Clerk : Component () { private val waitingLine : ComponentQueue < Customer > by inject () override fun process () = sequence { while ( true ) { if ( waitingLine . isEmpty ()) passivate () val customer = waitingLine . poll () customer . activate () // get the customer out of it's hold(50) hold ( 30.0 ) // bearbeitungszeit customer . activate () // signal the customer that's all's done } } } fun main () { val env = configureEnvironment ( true ) { // register components needed for dependency injection add { ComponentQueue < Customer > ( \"waitingline\" ) } add { ( 0. . 2 ). map { Clerk () } } } env . apply { // register other components to be present when starting the simulation CustomerGenerator () val waitingLine : ComponentQueue < Customer > = get () waitingLine . lengthOfStayMonitor . disable () run ( 1500.0 ) waitingLine . lengthOfStayMonitor . enable () run ( 500.0 ) // with console waitingLine . lengthOfStayMonitor . printHistogram () waitingLine . queueLengthMonitor . printHistogram () // with kravis // waitingLine.queueLengthMonitor.display() // waitingLine.lengthOfStayMonitor.display() waitingLine . stats . toJson (). toString ( 2 ). printThis () println ( \"number reneged: $ numReneged \" ) println ( \"number balked: $ numBalked \" ) } } Let's look at some details. cancel () This makes the current component (a customer) a DATA component (and be subject to garbage collection), if the queue length is 5 or more. The reneging is implemented after a hold of 50 . If a clerk can service a customer, it will take the customer out of the waitingline and will activate it at that moment. The customer just has to check whether he/she is still in the waiting line. If so, he/she has not been serviced in time and thus will renege. hold ( 50.0 ) if ( waitingLine . contains ( this @Customer )) { waitingLine . leave ( this @Customer ) numReneged ++ printTrace ( \"reneged\" ) } else { passivate () } All the clerk has to do when starting servicing a client is to get the next customer in line out of the queue (as before) and activate this customer (at time now). The effect is that the hold of the customer will end. hold ( 30.0 ) customer . activate () // signal the customer that's all's done","title":"Bank Office with Balking and Reneging"},{"location":"examples/bank_office/#bank-office-with-balking-and-reneging-resources","text":"Now we show how balking and reneging can be implemented with resources. The model code is: ////Bank3ClerksRenegingResources.kt package org.kalasim.examples.bank.reneging_resources import org.kalasim.* import org.koin.core.component.get //var numBalked = LevelMonitoredInt(0) var numBalked = 0 var numReneged = 0 class Customer ( val clerks : Resource ) : Component () { override fun process () = sequence { if ( clerks . requesters . size >= 5 ) { numBalked ++ log ( \"balked\" ) cancel () } request ( clerks , failDelay = 50 ) if ( failed ) { numReneged ++ log ( \"reneged\" ) } else { hold ( 30 ) release ( clerks ) } } } fun main () { declareDependencies { add { Resource ( \"clerks\" , capacity = 3 ) } }. createSimulation { // register other components to be present when starting the simulation ComponentGenerator ( iat = uniform ( 5.0 , 15.0 )) { Customer ( get ()) } run ( 50000.0 ) val clerks = get < Resource > () // with console clerks . requesters . queueLengthMonitor . printHistogram () clerks . requesters . lengthOfStayMonitor . printHistogram () // with kravis // clerks.requesters.queueLengthMonitor.display() // clerks.requesters.lengthOfStayMonitor.display() println ( \"number reneged: $ numReneged \" ) println ( \"number balked: $ numBalked \" ) } } As you can see, the balking part is exactly the same as in the example without resources. For the renenging, all we have to do is add a failDelay : request ( clerks , failDelay = 50. asDist ()) If the request is not honored within 50 time units (ticks), the process continues after that request statement. We check whether the request has failed with the built-in Component property: iff ( failed ) numReneged ++ This example shows clearly the advantage of the resource solution over the passivate / activate method, in former example.","title":"Bank Office with Balking and Reneging (resources)"},{"location":"examples/bank_office/#bank-office-with-states","text":"Another useful concept for modelling are states . In this case, we define a state called worktodo . The model code is: ////Bank3ClerksState.kt package org.kalasim.examples.bank.state import org.apache.commons.math3.distribution.UniformRealDistribution import org.kalasim.* import org.koin.core.component.get import org.koin.core.component.inject class CustomerGenerator : Component () { override fun process () = sequence { while ( true ) { Customer ( get (), get ()) hold ( UniformRealDistribution ( env . rg , 5.0 , 15.0 ). sample ()) } } } class Customer ( val workTodo : State < Boolean > , val waitingLine : ComponentQueue < Customer > ) : Component () { override fun process () = sequence { waitingLine . add ( this @Customer ) workTodo . trigger ( true , max = 1 ) passivate () } } class Clerk : Component () { val waitingLine : ComponentQueue < Customer > by inject () val workTodo : State < Boolean > by inject () override fun process () = sequence { while ( true ) { if ( waitingLine . isEmpty ()) wait ( workTodo , true ) val customer = waitingLine . poll () hold ( 32.0 ) // bearbeitungszeit customer . activate () } } } fun main () { val env = declareDependencies { // register components needed for dependency injection add { ComponentQueue < Customer > ( \"waitingline\" ) } add { State ( false , \"worktodo\" ) } }. createSimulation ( true ) { // register other components to be present // when starting the simulation repeat ( 3 ) { Clerk () } CustomerGenerator () }. run ( 500.0 ) env . get < ComponentQueue < Customer >> (). printStats () env . get < State < Boolean >> (). printInfo () // val waitingLine: ComponentQueue<Customer> = env.get() // waitingLine.stats.print() // waitingLine.queueLengthMonitor.display() } Let's look at some details. add { State ( false , \"worktodo\" ) } This defines a state with an initial value false and registers it as a dependency. In the code of the customer, the customer tries to trigger one clerk with: workTodo . trigger ( true , max = 1 ) The effect is that if there are clerks waiting for worktodo, the first clerk's wait is honored and that clerk continues its process after: wait ( workTodo , true ) Note that the clerk is only going to wait for worktodo after completion of a job if there are no customers waiting.","title":"Bank Office with States"},{"location":"examples/bank_office/#bank-office-with-standby","text":"The kalasim package contains yet another powerful process mechanism, called standby . When a component is in STANDBY mode, it will become current after each event. Normally, the standby will be used in a while loop where at every event one or more conditions are checked. The model with standby is: ////Bank3ClerksStandby.kt import org.kalasim.* import org.kalasim.plot.kravis.display import org.koin.core.component.get import org.koin.core.component.inject class Customer ( val waitingLine : ComponentQueue < Customer > ) : Component () { override fun process () = sequence { waitingLine . add ( this @Customer ) passivate () } } class Clerk : Component () { val waitingLine : ComponentQueue < Customer > by inject () override fun process () = sequence { while ( true ) { while ( waitingLine . isEmpty ()) standby () val customer = waitingLine . poll () hold ( 32.0 ) // bearbeitungszeit customer . activate () } } } fun main () { val env = declareDependencies { add { ComponentQueue < Customer > ( \"waitingline\" ) } }. createSimulation ( true ) { repeat ( 3 ) { Clerk () } ComponentGenerator ( uniform ( 5 , 15 )) { Customer ( get ()) } } env . run ( 500.0 ) env . get < ComponentQueue < Customer >> (). apply { printInfo () printStats () lengthOfStayMonitor . display () } } In this case, the condition is checked frequently with: while ( waitingLine . isEmpty ()) standby () The rest of the code is very similar to the version with states. Warning It is very important to realize that this mechanism can have significant impact on the performance, as after EACH event, the component becomes current and has to be checked. In general, it is recommended to try and use state s or a more straightforward passivate / activate construction.","title":"Bank Office with Standby"},{"location":"examples/car/","text":"A single car, a driver, and red traffic light in the middle of the night. Red Light , Matthias Ripp (CC BY 2.0) Let\u2019s start with a very simple model. The example demonstrates the main mode of operation, the core API and the component process model implemented in kalasim . We want to build a simulation where a single car is driving around for a some time before arriving at its destination. ////Cars.kts import org.kalasim.* class Driver : Resource () class TrafficLight : State < String > ( \"red\" ) class Car : Component () { val trafficLight = get < TrafficLight > () val driver = get < Driver > () override fun process () = sequence { request ( driver ) { hold ( 1.0 , description = \"driving\" ) wait ( trafficLight , \"green\" ) } } } createSimulation ( enableConsoleLogger = true ) { dependency { TrafficLight () } dependency { Driver () } Car () }. run ( 5.0 ) For each (active) component we (can) define a type such as: class Car : Component () The class inherits from org.kalasim.Component . Our car depends on a state TrafficLight and resource Driver for operation. To implement that, we first declare these dependencies with dependency{} in the main body of the simulation, and secondly inject them into our car with get<T> . Note, we could also directly inject states and resources with dependency {State(\"red\")} without sub-classing. Although it is possible to define other processes within a class, the standard way is to define a generator function called process in the class. A generator is a function that returns Sequence<Component> . Within these process definitions we use suspend able interaction function calls as a signal to give control to the centralized event loop . In this example, hold ( 1.0 ) suspends execution control and comes back after 1 time unit (referred to as tick ). Apart from hold , kalasim supports a rich vocabulary of interaction methods including passivate , request , wait and component . The main body of every kalasim model usually starts with: createSimulation(enableConsoleLogger = true){ ... } Here, we enable event logging of state changes to see the status of simulation on the console. After declaring our dependencies, we instantiate a single car with Car() . It automatically is assigned the name Car.0 . As there is a generator function called process in Car , this process description will be activated (by default at time now , which is 0 by default at the beginning of a simulation). It is possible to start a process later, but this is by far the most common way to start a process. With run ( 5.0 ) we start the simulation and get back control after 5 ticks. A component called main is defined under the hood to get access to the main process. When we run this program, we get the following output (displayed as table for convenience): time current receiver action info ------ -------- --------- ---------------------------------- ------------------- .00 main Created .00 main .00 Driver.1 Created capacity=1 .00 Car.1 Created .00 activate scheduled for .00 .00 main run +5.00 scheduled for 5.00 .00 Car.1 Car.1 .00 Requesting 1.0 from Driver.1 .00 Claimed 1.0 from 'Car.1' .00 Request honor Driver.1 scheduled for .00 .00 .00 hold +1.00 scheduled for 1.00 1.00 1.00 entering waiters of TrafficLight.1 1.00 wait scheduled for <inf> 5.00 main main Process finished with exit code 0 There are plenty of other more advanced (that is more fun !) examples listed in examples chapter.","title":"Car"},{"location":"examples/car_wash/","text":"In this example, we'll learn how to wait for resources. The example is adopted from the SimPy example . We simulate a carwash with a limited number of machines and a number of cars that arrive at the carwash to get cleaned. The carwash uses a resource to model the limited number of washing machines. It also defines a process for washing a car. When a car arrives at the carwash, it requests a machine. Once it got one, it starts the carwash\u2019s wash processes and waits for it to finish. It finally releases the machine and leaves. The cars are generated by a setup process. After creating an initial amount of cars it creates new car processes after a random time interval as long as the simulation continues. ////CarWash.kt import org.kalasim.* import org.koin.core.component.get /** * A carwash has a limited number of washing machines and defines * a washing processes that takes some (random) time. * * Car processes arrive at the carwash at a random time. If one washing * machine is available, they start the washing process and wait for it * to finish. If not, they wait until they an use one. */ fun main () { val RANDOM_SEED = 42 val NUM_MACHINES = 2 // Number of machines in the carwash val WASHTIME = 5 // Minutes it takes to clean a car val T_INTER = 7.0 // Create a car every ~7 minutes val SIM_TIME = 20 // Simulation time in minutes class Car : Component () { override fun process () = sequence { val carWash = get < Resource > () request ( carWash ) hold ( WASHTIME ) release ( carWash ) } } val env = declareDependencies { add { Resource ( \"carwash\" , NUM_MACHINES ) } }. createSimulation ( true , randomSeed = RANDOM_SEED ) { //Create 4 initial cars repeat ( 3 ) { Car () } // Create more cars while the simulation is running ComponentGenerator ( iat = uniform ( T_INTER - 2 , T_INTER + 2 )) { Car () } } println ( \"Carwash\\n======\\n\" ) println ( \"Check out http://youtu.be/fXXmeP9TvBg while simulating ... ;-)\" ) // Start the simulation env . run ( until = SIM_TIME . asTickTime ()) }","title":"Car Wash"},{"location":"examples/dining_philosophers/","text":"The Dining Philosophers problem is a classical example in computer science to illustrate synchronisation issues in concurrent processes. It was originally formulated in 1965 by E. W. Dijkstra as a student exam exercise, and was later reworked in its current form by Tony Hoare : Some philosophers sit at a round table with bowls of spaghetti with tomato sauce and tasty cheese. Forks are placed between each pair of adjacent philosophers. Each philosopher must alternately think and eat. However, a philosopher can only eat spaghetti when they have both left and right forks. Each fork can be held by only one philosopher and so a philosopher can use the fork only if it is not being used by another philosopher. After an individual philosopher finishes eating, they need to put down both forks so that the forks become available to others. A philosopher can take the fork on their right or the one on their left as they become available, but cannot start eating before getting both forks. The problem is how to design a discipline of behavior (a concurrent algorithm) such that no philosopher will starve; i.e., each can forever continue to alternate between eating and thinking, assuming no philosopher can know when others may want to eat or think. Simulation Let us define each philosopher as a process executing a thinking + eating loop, and acting concurrently on shared resources (the forks). Each process will follow a similar trajectory in which they Spend some random time thinking until they become hungry. Take one fork, when available, following a given policy. After some lag, take the other fork, when available. Spend some random time eating. Put both forks down and go back to 1. The following function sets up a simulation of $N$ dining philosophers as established above: ////DiningPhilosophers.kt package org.kalasim.examples import krangl.* import kravis.geomSegment import kravis.plot import org.kalasim.* import org.kalasim.misc.repeat import org.koin.core.component.get fun main () { class Fork : Resource () class Philosopher ( name : String , val leftFork : Fork , val rightFork : Fork ) : Component ( name ) { val thinking = exponential ( 1 ) val eating = exponential ( 1 ) override fun process () = sequence { while ( true ) { hold ( thinking ()) request ( leftFork ) { hold ( 0.1 ) // wait before taking the second fork request ( rightFork ) { hold ( eating ()) log ( \" $ name is eating\" ) } } } } } val sim = createSimulation ( true ) { traceCollector () // create forks and resources val names = listOf ( \"Socrates\" , \"Pythagoras\" , \"Plato\" , \"Aristotle\" ) val forks = repeat ( names . size ) { Fork () } //.repeat().take(names.size + 1).toList() names . forEachIndexed { idx , name -> Philosopher ( name , forks [ idx ] , forks [ ( idx + 1 ). rem ( forks . size ) ] ) } run ( 50 ) } // Analysis (gather monitoring data (as in simmer:get_mon_arrivals) data class RequestRecord ( val requester : String , val timestamp : TickTime , val resource : String , val quantity : Double ) val tc = sim . get < TraceCollector > () val requests = tc . filterIsInstance < ResourceEvent > (). map { val amountDirected = ( if ( it . type == ResourceEventType . RELEASED ) - 1 else 1 ) * it . amount RequestRecord ( it . requester . name , it . time , it . resource . name , amountDirected ) } // transform data into shape suiteable for interval plotting val requestsDf = requests . asDataFrame () . groupBy ( \"requester\" ) . sortedBy ( \"requester\" , \"timestamp\" ) . addColumn ( \"end_time\" ) { it [ \"timestamp\" ] . lag () } . addColumn ( \"state\" ) { rowNumber . map { if ( it . rem ( 2 ) == 0 ) \"hungry\" else \"eating\" } } . filter { it [ \"quantity\" ] gt 0 } . ungroup () // visualize with kravis requestsDf . plot ( x = \"timestamp\" , xend = \"end_time\" , y = \"requester\" , yend = \"requester\" , color = \"state\" ) . geomSegment ( size = 15.0 ) } To enable a strictly typed simulation, we declare the resource Fork and component Philosopher . The latter is associated to a process where the philosopher first thinks for some exponentially distributed time, takes a fork, meditates for a brief second, and finally takes the second fork once it becomes available. Both interactions modelled as request s where we use a self-releasing request context. Once the philosopher has eaten, the whole process starts over again. A variable number of philosophers (here N=4) is instantiated and are equipped with forks on their left and right. Our implementation follows the solution originally proposed by Dijkstra, which establishes the convention that all resources must be requested in order. This means that, in our simulation, Aristotle should pick fork 1 first instead. Without that convention, the simulation would stop soon at a point in which every philosopher holds one fork and waits for the other to be available. Finally, we can transform the resulting monitoring data with krangl and visualize it with kravis . See here for a jupyter notebook implementation of this example. This example was adopted from the simmer manual .","title":"Dining Philosophers"},{"location":"examples/dining_philosophers/#simulation","text":"Let us define each philosopher as a process executing a thinking + eating loop, and acting concurrently on shared resources (the forks). Each process will follow a similar trajectory in which they Spend some random time thinking until they become hungry. Take one fork, when available, following a given policy. After some lag, take the other fork, when available. Spend some random time eating. Put both forks down and go back to 1. The following function sets up a simulation of $N$ dining philosophers as established above: ////DiningPhilosophers.kt package org.kalasim.examples import krangl.* import kravis.geomSegment import kravis.plot import org.kalasim.* import org.kalasim.misc.repeat import org.koin.core.component.get fun main () { class Fork : Resource () class Philosopher ( name : String , val leftFork : Fork , val rightFork : Fork ) : Component ( name ) { val thinking = exponential ( 1 ) val eating = exponential ( 1 ) override fun process () = sequence { while ( true ) { hold ( thinking ()) request ( leftFork ) { hold ( 0.1 ) // wait before taking the second fork request ( rightFork ) { hold ( eating ()) log ( \" $ name is eating\" ) } } } } } val sim = createSimulation ( true ) { traceCollector () // create forks and resources val names = listOf ( \"Socrates\" , \"Pythagoras\" , \"Plato\" , \"Aristotle\" ) val forks = repeat ( names . size ) { Fork () } //.repeat().take(names.size + 1).toList() names . forEachIndexed { idx , name -> Philosopher ( name , forks [ idx ] , forks [ ( idx + 1 ). rem ( forks . size ) ] ) } run ( 50 ) } // Analysis (gather monitoring data (as in simmer:get_mon_arrivals) data class RequestRecord ( val requester : String , val timestamp : TickTime , val resource : String , val quantity : Double ) val tc = sim . get < TraceCollector > () val requests = tc . filterIsInstance < ResourceEvent > (). map { val amountDirected = ( if ( it . type == ResourceEventType . RELEASED ) - 1 else 1 ) * it . amount RequestRecord ( it . requester . name , it . time , it . resource . name , amountDirected ) } // transform data into shape suiteable for interval plotting val requestsDf = requests . asDataFrame () . groupBy ( \"requester\" ) . sortedBy ( \"requester\" , \"timestamp\" ) . addColumn ( \"end_time\" ) { it [ \"timestamp\" ] . lag () } . addColumn ( \"state\" ) { rowNumber . map { if ( it . rem ( 2 ) == 0 ) \"hungry\" else \"eating\" } } . filter { it [ \"quantity\" ] gt 0 } . ungroup () // visualize with kravis requestsDf . plot ( x = \"timestamp\" , xend = \"end_time\" , y = \"requester\" , yend = \"requester\" , color = \"state\" ) . geomSegment ( size = 15.0 ) } To enable a strictly typed simulation, we declare the resource Fork and component Philosopher . The latter is associated to a process where the philosopher first thinks for some exponentially distributed time, takes a fork, meditates for a brief second, and finally takes the second fork once it becomes available. Both interactions modelled as request s where we use a self-releasing request context. Once the philosopher has eaten, the whole process starts over again. A variable number of philosophers (here N=4) is instantiated and are equipped with forks on their left and right. Our implementation follows the solution originally proposed by Dijkstra, which establishes the convention that all resources must be requested in order. This means that, in our simulation, Aristotle should pick fork 1 first instead. Without that convention, the simulation would stop soon at a point in which every philosopher holds one fork and waits for the other to be available. Finally, we can transform the resulting monitoring data with krangl and visualize it with kravis . See here for a jupyter notebook implementation of this example. This example was adopted from the simmer manual .","title":"Simulation"},{"location":"examples/ferryman/","text":"A wild river, one boat only, and a patient ferryman transporting batches of passengers across the body of water. Covers: Batching to consume queue elements in defined blocks Monitors for stats and visualization Stanhope Forbes - A Ferryman at Flushing (oil on canvas, CC0 1.0) Simulation To form groups of passengers before passing the waters, we use batch() in the ferryman's process definition . It has multiple arguments: A mandatory queue with elements of type <T> to be consumed The size of the batch to be created. A positive integer is expected here. An optional timeout describing how long it shall wait before forming an incomplete/empty batch batch will return a list of type <T> of size batchSize or lesser (and potentially even empty) if timed out before filling the batch. ////Ferryman.kts package org.kalasim.examples import org.kalasim.* import org.kalasim.plot.kravis.display import org.kalasim.monitors.NumericStatisticMonitor createSimulation { class Passenger : Component () val fm = object : Component ( \"ferryman\" ) { val left2Right = ComponentQueue < Passenger > () val right2Left = ComponentQueue < Passenger > () val l2rMonitor = NumericStatisticMonitor () val r2lMonitor = NumericStatisticMonitor () override fun process () = sequence { val batchLR : List < Passenger > = batch ( left2Right , 4 , timeout = 10 ) l2rMonitor . addValue ( batchLR . size ) hold ( 5 , description = \"shipping ${ batchLR . size } l2r\" ) val batchRL : List < Passenger > = batch ( right2Left , 4 , timeout = 10 ) r2lMonitor . addValue ( batchRL . size ) hold ( 5 , description = \"shipping ${ batchRL . size } r2l\" ) // we could also use an infinite while loop instead of activate yield ( activate ( process = Component :: process )) } } ComponentGenerator ( uniform ( 0 , 15 )) { Passenger () } . addConsumer { fm . left2Right . add ( it ) } ComponentGenerator ( uniform ( 0 , 12 )) { Passenger () } . addConsumer { fm . right2Left . add ( it ) } run ( 10000 ) fm . l2rMonitor . display ( \"Passengers left->right\" ) fm . r2lMonitor . display ( \"Passengers right->left\" ) } Analysis The ferryman tries to max out his boat with 4 passengers, but after 10 minutes he will start anyway (even if the boat is entirely emtpy). kalasim will suspend execution when using batch() until timeout or indefinitely (if timeout is not set). Since both banks have different arrival distributions, we observe different batch-size patterns: Right\u2192Left Since passengers on the right bank arrive with a higher rate (that is shorter inter-arrival time between 0 and 12 ), the ferry is usually packed with people. Only occasionally the ferryman traverses from left to right banks with less than 4 passengers. Left\u2192Right Because of a slightly higher inter-arrival time (up to 15 minutes) on the left banks, it often happens that the ferry starts its journey across the river with some seats unoccupied. On average, just 3 seats are taken. However, at least during this simulation we did not encounter a passing with just the ferryman and his thoughts.","title":"The Ferryman"},{"location":"examples/ferryman/#simulation","text":"To form groups of passengers before passing the waters, we use batch() in the ferryman's process definition . It has multiple arguments: A mandatory queue with elements of type <T> to be consumed The size of the batch to be created. A positive integer is expected here. An optional timeout describing how long it shall wait before forming an incomplete/empty batch batch will return a list of type <T> of size batchSize or lesser (and potentially even empty) if timed out before filling the batch. ////Ferryman.kts package org.kalasim.examples import org.kalasim.* import org.kalasim.plot.kravis.display import org.kalasim.monitors.NumericStatisticMonitor createSimulation { class Passenger : Component () val fm = object : Component ( \"ferryman\" ) { val left2Right = ComponentQueue < Passenger > () val right2Left = ComponentQueue < Passenger > () val l2rMonitor = NumericStatisticMonitor () val r2lMonitor = NumericStatisticMonitor () override fun process () = sequence { val batchLR : List < Passenger > = batch ( left2Right , 4 , timeout = 10 ) l2rMonitor . addValue ( batchLR . size ) hold ( 5 , description = \"shipping ${ batchLR . size } l2r\" ) val batchRL : List < Passenger > = batch ( right2Left , 4 , timeout = 10 ) r2lMonitor . addValue ( batchRL . size ) hold ( 5 , description = \"shipping ${ batchRL . size } r2l\" ) // we could also use an infinite while loop instead of activate yield ( activate ( process = Component :: process )) } } ComponentGenerator ( uniform ( 0 , 15 )) { Passenger () } . addConsumer { fm . left2Right . add ( it ) } ComponentGenerator ( uniform ( 0 , 12 )) { Passenger () } . addConsumer { fm . right2Left . add ( it ) } run ( 10000 ) fm . l2rMonitor . display ( \"Passengers left->right\" ) fm . r2lMonitor . display ( \"Passengers right->left\" ) }","title":"Simulation"},{"location":"examples/ferryman/#analysis","text":"The ferryman tries to max out his boat with 4 passengers, but after 10 minutes he will start anyway (even if the boat is entirely emtpy). kalasim will suspend execution when using batch() until timeout or indefinitely (if timeout is not set). Since both banks have different arrival distributions, we observe different batch-size patterns: Right\u2192Left Since passengers on the right bank arrive with a higher rate (that is shorter inter-arrival time between 0 and 12 ), the ferry is usually packed with people. Only occasionally the ferryman traverses from left to right banks with less than 4 passengers. Left\u2192Right Because of a slightly higher inter-arrival time (up to 15 minutes) on the left banks, it often happens that the ferry starts its journey across the river with some seats unoccupied. On average, just 3 seats are taken. However, at least during this simulation we did not encounter a passing with just the ferryman and his thoughts.","title":"Analysis"},{"location":"examples/gas_station/","text":"Gas Station This example models a gas station and cars that arrive at the station for refueling. Covers: Depletable Resources Process Interaction, in particular waiting for other processes The gas station has a limited number of fuel pumps, and a fuel tank that is shared between the fuel pumps. The gas station is thus modeled as Resource . The shared fuel tank is modeled with a DepletableResource . Vehicles arriving at the gas station first request a fuel pump from the station. Once they acquire one, they try to take the desired amount of fuel from the fuel pump. They leave when they are done. The gas stations fuel level is regularly monitored by gas station control. When the level drops below a certain threshold, a tank truck is called to refuel the gas station itself. //package org.kalasim.examples import org.apache.commons.math3.distribution.UniformRealDistribution import org.kalasim.* import org.kalasim.misc.printThis import org.koin.core.component.get import org.koin.core.component.inject import org.koin.core.qualifier.named /** * A car arrives at the gas station for refueling. * * It requests one of the gas station's fuel pumps and tries to get the * desired amount of gas from it. If the stations reservoir is * depleted, the car has to wait for the tank truck to arrive. */ object GasStation { // based on SimPy example model val GAS_STATION_SIZE = 200.0 // liters val THRESHOLD = 25.0 // Threshold for calling the tank truck (in %) val FUEL_TANK_SIZE = 50.0 // liters val FUEL_TANK_LEVEL = UniformRealDistribution ( 5.0 , 25.0 ) // Min/max levels of fuel tanks (in liters) val REFUELING_SPEED = 2.0 // liters / second val TANK_TRUCK_TIME = 300.0 // Seconds it takes the tank truck to arrive val T_INTER = UniformRealDistribution ( 10.0 , 100.0 ) // Create a car every [min, max] seconds // val SIM_TIME = 200000.0 // Original Simulation time in seconds val SIM_TIME = 20000.0 // Simulation time in seconds private val FUEL_PUMP = \"fuel_pump\" @JvmStatic fun main ( args : Array < String > ) { class GasStation : Resource ( capacity = 2 ) class TankTruck : Component () { val fuelPump : DepletableResource by inject ( qualifier = named ( FUEL_PUMP )) override fun process () = sequence { hold ( TANK_TRUCK_TIME ) val amount = fuelPump . claimed put ( fuelPump withQuantity amount ) } } // we can either inject by constructor... class Car ( val gasStation : GasStation ) : Component () { // ... or we can inject by field which is // in particular useful for untypes resources and components // val gasStation : Resource by inject(qualifier = named(\"gas_station\")) val fuelPump : DepletableResource by inject ( qualifier = named ( FUEL_PUMP )) override fun process () = sequence { val fuelTankLevel = FUEL_TANK_LEVEL . sample () request ( gasStation ) val litersRequired = FUEL_TANK_SIZE - fuelTankLevel // order a new Tank if the fuelpump runs of out fuel if (( fuelPump . availableQuantity - litersRequired ) / fuelPump . capacity * 100 < THRESHOLD ) { log ( \"running out of fuel at $ gasStation . Ordering new fuel truck...\" ) TankTruck () } request ( fuelPump withQuantity litersRequired ) hold ( litersRequired / REFUELING_SPEED ) } } configureEnvironment ( true ) { // single(qualifier = named(\"gas_station\")) { Resource(\"gas_station\", 2) } single { GasStation () } single ( qualifier = named ( FUEL_PUMP )) { DepletableResource ( FUEL_PUMP , GAS_STATION_SIZE ) } }. apply { ComponentGenerator ( iat = T_INTER ) { Car ( get ()) } run ( SIM_TIME ) val fuelPump = get < DepletableResource > ( qualifier = named ( FUEL_PUMP )) fuelPump . apply { capacityMonitor . printHistogram () claimedMonitor . printHistogram () availableMonitor . printHistogram () // capacityMonitor.display() // claimedQuantityMonitor.display() // availableQuantityMonitor.display() } get < GasStation > (). requesters . apply { queueLengthMonitor . printThis () lengthOfStayMonitor . printThis () } } } } Here, we use both lazy injection with inject<T>() and instance retrieval with get<T>() . For details see koin reference The example is a true classic and was adopted from salabim 's and SimPy 's gas stations.","title":"Gas Station"},{"location":"examples/gas_station/#gas-station","text":"This example models a gas station and cars that arrive at the station for refueling. Covers: Depletable Resources Process Interaction, in particular waiting for other processes The gas station has a limited number of fuel pumps, and a fuel tank that is shared between the fuel pumps. The gas station is thus modeled as Resource . The shared fuel tank is modeled with a DepletableResource . Vehicles arriving at the gas station first request a fuel pump from the station. Once they acquire one, they try to take the desired amount of fuel from the fuel pump. They leave when they are done. The gas stations fuel level is regularly monitored by gas station control. When the level drops below a certain threshold, a tank truck is called to refuel the gas station itself. //package org.kalasim.examples import org.apache.commons.math3.distribution.UniformRealDistribution import org.kalasim.* import org.kalasim.misc.printThis import org.koin.core.component.get import org.koin.core.component.inject import org.koin.core.qualifier.named /** * A car arrives at the gas station for refueling. * * It requests one of the gas station's fuel pumps and tries to get the * desired amount of gas from it. If the stations reservoir is * depleted, the car has to wait for the tank truck to arrive. */ object GasStation { // based on SimPy example model val GAS_STATION_SIZE = 200.0 // liters val THRESHOLD = 25.0 // Threshold for calling the tank truck (in %) val FUEL_TANK_SIZE = 50.0 // liters val FUEL_TANK_LEVEL = UniformRealDistribution ( 5.0 , 25.0 ) // Min/max levels of fuel tanks (in liters) val REFUELING_SPEED = 2.0 // liters / second val TANK_TRUCK_TIME = 300.0 // Seconds it takes the tank truck to arrive val T_INTER = UniformRealDistribution ( 10.0 , 100.0 ) // Create a car every [min, max] seconds // val SIM_TIME = 200000.0 // Original Simulation time in seconds val SIM_TIME = 20000.0 // Simulation time in seconds private val FUEL_PUMP = \"fuel_pump\" @JvmStatic fun main ( args : Array < String > ) { class GasStation : Resource ( capacity = 2 ) class TankTruck : Component () { val fuelPump : DepletableResource by inject ( qualifier = named ( FUEL_PUMP )) override fun process () = sequence { hold ( TANK_TRUCK_TIME ) val amount = fuelPump . claimed put ( fuelPump withQuantity amount ) } } // we can either inject by constructor... class Car ( val gasStation : GasStation ) : Component () { // ... or we can inject by field which is // in particular useful for untypes resources and components // val gasStation : Resource by inject(qualifier = named(\"gas_station\")) val fuelPump : DepletableResource by inject ( qualifier = named ( FUEL_PUMP )) override fun process () = sequence { val fuelTankLevel = FUEL_TANK_LEVEL . sample () request ( gasStation ) val litersRequired = FUEL_TANK_SIZE - fuelTankLevel // order a new Tank if the fuelpump runs of out fuel if (( fuelPump . availableQuantity - litersRequired ) / fuelPump . capacity * 100 < THRESHOLD ) { log ( \"running out of fuel at $ gasStation . Ordering new fuel truck...\" ) TankTruck () } request ( fuelPump withQuantity litersRequired ) hold ( litersRequired / REFUELING_SPEED ) } } configureEnvironment ( true ) { // single(qualifier = named(\"gas_station\")) { Resource(\"gas_station\", 2) } single { GasStation () } single ( qualifier = named ( FUEL_PUMP )) { DepletableResource ( FUEL_PUMP , GAS_STATION_SIZE ) } }. apply { ComponentGenerator ( iat = T_INTER ) { Car ( get ()) } run ( SIM_TIME ) val fuelPump = get < DepletableResource > ( qualifier = named ( FUEL_PUMP )) fuelPump . apply { capacityMonitor . printHistogram () claimedMonitor . printHistogram () availableMonitor . printHistogram () // capacityMonitor.display() // claimedQuantityMonitor.display() // availableQuantityMonitor.display() } get < GasStation > (). requesters . apply { queueLengthMonitor . printThis () lengthOfStayMonitor . printThis () } } } } Here, we use both lazy injection with inject<T>() and instance retrieval with get<T>() . For details see koin reference The example is a true classic and was adopted from salabim 's and SimPy 's gas stations.","title":"Gas Station"},{"location":"examples/machine_parts/","text":"This model demonstrates the use of stacked interrupts. It is adopted from here . Each of two machines has three parts, that will be subject to failure. If one or more of these parts has failed, the machine is stopped. Only when all parts are operational, the machine can continue its work (hold). For a machine to work it needs the resource. If, during the requesting of this resource, one or more parts of that machine break down, the machine stops requesting until all parts are operational. In this model the interrupt level frequently gets to 2 or 3 (all parts broken down). Have a close look at the trace output to see what is going on. ////MachineWithParts.kt import org.kalasim.* class Part ( val machine : Machine , partNo : Int ) : Component ( name = machine . name . replace ( \"Machine\" , \"part\" ) + \". ${ partNo + 1 } \" ) { val ttf = uniform ( 19 , 20 ) // time to failure distribution val ttr = uniform ( 3 , 6 ) // time to repair distribution override fun process () = sequence { while ( true ) { hold ( ttf ()) machine . interrupt () hold ( ttr ()) machine . resume () } } } class Machine : Component () { init { repeat ( 3 ) { Part ( this , it ) } } override fun process () = sequence { while ( true ) { val r = get < Resource > () request ( r ) hold ( 5 ) release ( r ) } } } fun main () { createSimulation ( true ) { dependency { Resource () } repeat ( 2 ) { Machine () } run ( 400 ) } }","title":"Machine Parts"},{"location":"examples/machine_shop/","text":"In this example, we'll learn how to interrupt a process because of more important tasks. The example is adopted from the SimPy Machine Shop Example . The example covers interrupt and preemptive resources . The example comprises a workshop with n identical machines. A stream of jobs (enough to keep the machines busy) arrives. Each machine breaks down periodically. Repairs are carried out by one repairman. The repairman has other, less important tasks to perform, too. Broken machines preempt these tasks. The repairman continues them when he is done with the machine repair. The workshop works continuously. A machine has two processes: working implements the actual behaviour of the machine (producing parts). break_machine periodically interrupts the working process to simulate the machine failure. In kalasim there can only be one generating process per component. So to model the wear, we use a separate MachineWear which is interrupt ing the machine in case of failure. The repairman\u2019s other job is also a process (implemented by otherJob). The repairman itself is a preemptive resource with a capacity of 1 . The machine repairing has a priority of 1, while the other job has a priority of 2 (the smaller the number, the higher the priority). ////MachineShop.kt import org.apache.commons.math3.distribution.RealDistribution import org.kalasim.* val RANDOM_SEED : Int = 42 val PT_MEAN : Double = 10.0 // Avg. processing time in minutes val PT_SIGMA : Double = 2.0 // Sigma of processing time val MTTF : Double = 300.0 // Mean time to failure in minutes val REPAIR_TIME : Double = 30.0 // Time it takes to repair a machine in minutes val JOB_DURATION : Double = 30.0 // Duration of other jobs in minutes val NUM_MACHINES : Int = 10 // Number of machines in the machine shop val WEEKS : Int = 4 // Simulation time in weeks val SIM_TIME : Number = WEEKS * 7 * 24 * 60 // Simulation time in minutes fun main () { class Machine : Component () { var madeParts : Int = 0 private set val timePerPart : RealDistribution = normal ( PT_MEAN , PT_SIGMA ) override fun process (): Sequence < Component > = sequence { while ( true ) { // start working on a new part log ( \"building a new part\" ) hold ( timePerPart ()) log ( \"finished building part\" ) madeParts ++ } } } /** Break the machine every now and then. */ class MachineWear ( val machine : Machine , val repairMan : Resource ) : Component ( process = MachineWear :: breakMachine ) { fun breakMachine (): Sequence < Component > = sequence { val timeToFailure = exponential ( MTTF ) while ( true ) { hold ( timeToFailure ()) // handle the rare case that the model if ( machine . isInterrupted ) continue machine . interrupt () request ( repairMan ) hold ( REPAIR_TIME ) require ( ! isBumped ( repairMan )) { \"productive tools must not be bumped\" } release ( repairMan ) machine . resume () require ( ! machine . isInterrupted ) { \"machine must not be interrupted at end of wear cycle\" } } } } createSimulation ( true , randomSeed = RANDOM_SEED ) { val repairMan = Resource ( \"mechanic\" , preemptive = true ) // create N machines and wear components val tools = ( 1. . NUM_MACHINES ). map { Machine (). also { MachineWear ( it , repairMan ) } } // define the other jobs as object expression // https://kotlinlang.org/docs/reference/object-declarations.html#object-expressions object : Component ( \"side jobs\" ) { override fun process () = sequence { while ( true ) { request ( ResourceRequest ( repairMan , priority = Priority ( - 1 ))) hold ( JOB_DURATION ) if ( isBumped ( repairMan )) { log ( \"other job was bumped\" ) continue } release ( repairMan ) } } } // Run simulation run ( 1000 ) run ( SIM_TIME ) // Analysis tools . forEach { println ( \" ${ it . name } made ${ it . madeParts } parts.\" ) } } }","title":"Machine Shop"},{"location":"examples/misc/","text":"Coroutine Channels ////LogChannelConsumer.kts package org.kalasim.examples.analysis import kotlinx.coroutines.GlobalScope import kotlinx.coroutines.channels.Channel import kotlinx.coroutines.flow.collect import kotlinx.coroutines.flow.filter import kotlinx.coroutines.flow.receiveAsFlow import kotlinx.coroutines.launch import org.kalasim.* class MyEventConsumer : EventListener { // think of it as a Non Blocking Queue val ordersChannel = Channel < Event > () override fun consume ( event : Event ) { GlobalScope . launch { ordersChannel . offer ( event ) } } } val tl = MyEventConsumer () // Start a log consumer GlobalScope . launch { tl . ordersChannel . receiveAsFlow (). filter { it is InteractionEvent && it . curComponent ?. name == \"ComponentGenerator.1\" }. collect { println ( it ) } } // create simulation with no default logging val sim = createSimulation { ComponentGenerator ( iat = 1. asDist ()) { Component ( \"Car. ${ it } \" ) } // add custom log consumer addEventListener ( tl ) // run the simulation run ( 100 ) }","title":"Misc"},{"location":"examples/misc/#coroutine-channels","text":"////LogChannelConsumer.kts package org.kalasim.examples.analysis import kotlinx.coroutines.GlobalScope import kotlinx.coroutines.channels.Channel import kotlinx.coroutines.flow.collect import kotlinx.coroutines.flow.filter import kotlinx.coroutines.flow.receiveAsFlow import kotlinx.coroutines.launch import org.kalasim.* class MyEventConsumer : EventListener { // think of it as a Non Blocking Queue val ordersChannel = Channel < Event > () override fun consume ( event : Event ) { GlobalScope . launch { ordersChannel . offer ( event ) } } } val tl = MyEventConsumer () // Start a log consumer GlobalScope . launch { tl . ordersChannel . receiveAsFlow (). filter { it is InteractionEvent && it . curComponent ?. name == \"ComponentGenerator.1\" }. collect { println ( it ) } } // create simulation with no default logging val sim = createSimulation { ComponentGenerator ( iat = 1. asDist ()) { Component ( \"Car. ${ it } \" ) } // add custom log consumer addEventListener ( tl ) // run the simulation run ( 100 ) }","title":"Coroutine Channels"},{"location":"examples/movie_theater/","text":"Movie Theater Covers: Resources Event operators Shared events This example models a movie theater with one ticket counter selling tickets for three movies (next show only). People arrive at random times and try to buy a random number (1\u20136) tickets for a random movie. When a movie is sold out, all people waiting to buy a ticket for that movie renege (leave the queue). The movie theater is just a type to assemble all the related data (movies, the counter, tickets left, collected data, ...). The counter is a Resource with a capacity of one. The moviegoer process function starts waiting until either it\u2019s his turn (it acquires the counter resource) or until the sold out signal is triggered. If the latter is the case it reneges (leaves the queue). If it gets to the counter, it tries to buy some tickets. This might not be successful, e.g. if the process tries to buy 5 tickets but only 3 are left. If less than two tickets are left after the ticket purchase, the sold out signal is triggered. Moviegoers are generated by the customer arrivals process. It also chooses a movie, and the number of tickets for the moviegoer. ////MovieRenege.kt import org.kalasim.* import org.kalasim.misc.roundAny fun main () { val RANDOM_SEED = 158 val TICKETS = 50 // Number of tickets per movie val SIM_TIME = 120.0 // Simulate until data class Movie ( val name : String ) val MOVIES = listOf ( \"Julia Unchained\" , \"Kill Process\" , \"Pulp Implementation\" ). map { Movie ( it ) } createSimulation ( true , randomSeed = RANDOM_SEED ) { // note: it's not really needed to model the theater (because it has no process), but we follow the julia model here val theater = object { val tickets = MOVIES . map { it to DepletableResource ( \"room ${ MOVIES . indexOf ( it ) } \" , capacity = TICKETS ) }. toMap () val numReneged = MOVIES . map { it to 0 }. toMap (). toMutableMap () val counter = Resource ( \"counter\" , capacity = 1 ) } class Cineast ( val movie : Movie , val numTickets : Int ) : Component () { override fun process () = sequence { request ( theater . counter ) { request ( theater . tickets [ movie ]!! withQuantity numTickets , failAt = 0. tickTime ) if ( failed ) { theater . numReneged . merge ( movie , 1 , Int :: plus ) } } } } ComponentGenerator ( iat = exponential ( 0.5 )) { Cineast ( MOVIES . random (), discreteUniform ( 1 , 6 ). sample ()) } run ( SIM_TIME ) MOVIES . forEach { movie -> val numLeftQueue = theater . numReneged [ movie ]!! val soldOutSince = theater . tickets [ movie ]!! . occupancyMonitor . stepFun () // find the first time when tickets were sold out . first { it . second == 1.0 }. first . roundAny ( 2 ) println ( \"Movie ${ movie . name } sold out $ soldOutSince minutes after ticket counter opening.\" ) println ( \" $ numLeftQueue walked away after film was sold out.\" ) } // // Visualize ticket sales // val plotData = theater.tickets.values.flatMap { // it.occupancyMonitor.stepFun().map { sf -> Triple(it.name, sf.first, sf.second) } // } // // plotData.asDataFrame().plot(x = \"second\", y = \"third\") // .geomStep().facetWrap(\"first\").title(\"Theater Occupancy\") // .xLabel(\"Time (min)\").yLabel(\"Occupancy\") } } The example also details out how we could now easily plot the occupancy progressions using automatically captured monitoring data. Adopted from SimJulia example .","title":"Movie Theater"},{"location":"examples/movie_theater/#movie-theater","text":"Covers: Resources Event operators Shared events This example models a movie theater with one ticket counter selling tickets for three movies (next show only). People arrive at random times and try to buy a random number (1\u20136) tickets for a random movie. When a movie is sold out, all people waiting to buy a ticket for that movie renege (leave the queue). The movie theater is just a type to assemble all the related data (movies, the counter, tickets left, collected data, ...). The counter is a Resource with a capacity of one. The moviegoer process function starts waiting until either it\u2019s his turn (it acquires the counter resource) or until the sold out signal is triggered. If the latter is the case it reneges (leaves the queue). If it gets to the counter, it tries to buy some tickets. This might not be successful, e.g. if the process tries to buy 5 tickets but only 3 are left. If less than two tickets are left after the ticket purchase, the sold out signal is triggered. Moviegoers are generated by the customer arrivals process. It also chooses a movie, and the number of tickets for the moviegoer. ////MovieRenege.kt import org.kalasim.* import org.kalasim.misc.roundAny fun main () { val RANDOM_SEED = 158 val TICKETS = 50 // Number of tickets per movie val SIM_TIME = 120.0 // Simulate until data class Movie ( val name : String ) val MOVIES = listOf ( \"Julia Unchained\" , \"Kill Process\" , \"Pulp Implementation\" ). map { Movie ( it ) } createSimulation ( true , randomSeed = RANDOM_SEED ) { // note: it's not really needed to model the theater (because it has no process), but we follow the julia model here val theater = object { val tickets = MOVIES . map { it to DepletableResource ( \"room ${ MOVIES . indexOf ( it ) } \" , capacity = TICKETS ) }. toMap () val numReneged = MOVIES . map { it to 0 }. toMap (). toMutableMap () val counter = Resource ( \"counter\" , capacity = 1 ) } class Cineast ( val movie : Movie , val numTickets : Int ) : Component () { override fun process () = sequence { request ( theater . counter ) { request ( theater . tickets [ movie ]!! withQuantity numTickets , failAt = 0. tickTime ) if ( failed ) { theater . numReneged . merge ( movie , 1 , Int :: plus ) } } } } ComponentGenerator ( iat = exponential ( 0.5 )) { Cineast ( MOVIES . random (), discreteUniform ( 1 , 6 ). sample ()) } run ( SIM_TIME ) MOVIES . forEach { movie -> val numLeftQueue = theater . numReneged [ movie ]!! val soldOutSince = theater . tickets [ movie ]!! . occupancyMonitor . stepFun () // find the first time when tickets were sold out . first { it . second == 1.0 }. first . roundAny ( 2 ) println ( \"Movie ${ movie . name } sold out $ soldOutSince minutes after ticket counter opening.\" ) println ( \" $ numLeftQueue walked away after film was sold out.\" ) } // // Visualize ticket sales // val plotData = theater.tickets.values.flatMap { // it.occupancyMonitor.stepFun().map { sf -> Triple(it.name, sf.first, sf.second) } // } // // plotData.asDataFrame().plot(x = \"second\", y = \"third\") // .geomStep().facetWrap(\"first\").title(\"Theater Occupancy\") // .xLabel(\"Time (min)\").yLabel(\"Occupancy\") } } The example also details out how we could now easily plot the occupancy progressions using automatically captured monitoring data. Adopted from SimJulia example .","title":"Movie Theater"},{"location":"examples/office_tower/","text":"Here, we simulate logistics in an office tower. There are 3 lifts with capacity limited cars. Passengers arrive at different floors with different rates and press buttons indicating the direction of their target floor. The cars have a defined speed, and clearly it takes time to open/close its doors before passengers can enter & leaver. Parameters Origin/destination distribution of visitors Number of elevators Capacity of each elevator See here for the implementation The implementation is inspired by salabim's elevator example.","title":"Office Tower"},{"location":"examples/traffic/","text":"The following example integrates three simulation entities A gas station with a limited number of pumps A traffic light that prevents cars from driving Multiple cars that need to pass the cross with the traffic light to reach a gas station. There each car needs to refill before it is reaching its end of live within the simulation context. The example illustrates how to establish a simple interplay of states and resources . It is realized elegantly with dependency injection . ////Traffic.kts import org.kalasim.* import org.koin.core.component.get import org.koin.core.component.inject class TrafficLight : State < String > ( \"red\" ) class GasStation ( numPumps : Int = 6 ) : Resource ( capacity = numPumps ) class Car ( val trafficLight : TrafficLight ) : Component () { val gasStation by inject < GasStation > () override fun process () = sequence { // wait until the traffic light is green wait ( trafficLight , \"green\" ) // request a slot in the gas-station request ( gasStation ) // refill hold ( 5 ) // release pump release ( gasStation ) // change state of car to DATA passivate () } } val env : Environment = configureEnvironment ( true ) { // Add a traffic light so that we can refer to it via koin get<T>() add { TrafficLight () } // Also add a resource with a limited capacity add { GasStation ( 2 ) } // we could add a car here... add { Car ( get ()) } }. apply { // ... but since a car is not used as dependency elsewhere we // can also create them in here val car2 = Car ( get ()) val car3 = Car ( get ()) // run for 10 ticks run ( 10 ) // toggle the traffic light get < TrafficLight > (). value = \"green\" // run for another 10 ticks run ( 10 ) // assess the state of the simulation entities car2 . statusMonitor . printHistogram () get < GasStation > (). printStatistics () } Here, we use both lazy injection with inject<T>() and instance retrieval with get<T>() . For details see koin reference","title":"Traffic"}]}